# [PURPLE] Task Owner: Стабилизировать WinDivert-bypass и устранить конфликт Flow/RST

> Цель: довести bypass-архитектуру до состояния, когда TLS-фрагментация, RST-блокер и диагностические инструменты могут работать совместно и предсказуемо, а LiveTesting получает воспроизводимые результаты по обходу провайдерского DPI.

---

## Проблема

**Краткое описание**:
Текущая реализация обхода DPI в `WinDivertBypassManager` нестабильна: RST-блокер на Network-слое часто не открывается из-за конфликта с Flow-слоем/другими хэндлами, в результате чего даже при активной TLS-фрагментации провайдерские TCP RST по-прежнему доходят до приложений (FsHud, Star Citizen, RSI Launcher). Flow-диагностика и bypass-сессия конкурируют за одни и те же события, архитектурные роли слоёв не разведены.

**Как проявляется** (для багов):
```
1. В логах bypass-а: TLS ClientHello успешно обнаруживаются и фрагментируются.
2. При этом RST-блокер либо не стартует (warning о невозможности открыть хэндл), либо не логирует ни одного "RST DROPPED".
3. В сетевом трафике и логах приложений видны RST сразу после ClientHello / в начале TLS-handshake.
4. LiveTesting/авторизация Star Citizen / FsHud часто проваливается, несмотря на включенный bypass.
```

**Контекст**:

- Критичность: HIGH (без стабильного bypass основная фича LiveTesting и диагностики DPI-цензуры работает непредсказуемо, пользователю сложно понять, помогает ли инструмент)

---

## Желаемый результат (Definition of Done)

После выполнения:
1. WinDivert-архитектура разделяет роли слоёв: Network-слой отвечает за реальный обход (TLS-фрагментация, RST-блокер, DNS-редирект), а Flow/диагностика не мешают работе RST-хэндла.
2. RST-блокер на Network-слое надёжно открывается, стабильно видит и дропает как входящие, так и исходящие RST-пакеты в сценариях с провайдерским DPI.
3. TLS-фрагментация работает таргетированно (по профилям/критическим целям) и даёт измеримый прирост успешных TLS-handshake в LiveTesting.

Критерии приёмки:
- При включённом bypass для тестовых целей (Star Citizen / FsHud) в логах появляются события вида `RST DROPPED: ...`, а количество RST от провайдера заметно падает по сравнению с режимом без обхода.
- При конфигурации "diag only" Flow-/TrafficAnalyzer может работать без активного bypass, а при активной bypass-сессии режимы "diag" и "active bypass" разведены так, чтобы не ломать RST-блокер (вариант A/C из deep-dive).
- LiveTesting показывает устойчивый рост **TLS Handshake Success Rate** на проблемных доменах при включённом обходе (по крайней мере на тестовом стенде/провайдере) и не вводит в заблуждение пользователя ложными успешными статусами.
- Нет регрессий: при выключенном bypass поведение сети и диагностических тестов остаётся таким же, как сейчас.

---

## Ограничения

**Технические**:
- .NET 9, WPF + MaterialDesign
- Всё, что связано с WinDivert, должно соблюдать async-подход и аккуратную работу с фоновой обработкой пакетов, без блокировок GUI.
- Обратная совместимость: да (существующие профили и режимы LiveTesting должны продолжить работать, возможны только расширения настроек bypass-а).

**Что НЕ делать**:
- Не реализовывать сразу все продвинутые техники (сложный Fake Request Mode, auto-TTL, reverse-frag и т.п.) — сначала стабилизировать базовую связку TLS_FRAG + RST_BLOCK + (минимальный) DNS_REDIR.
- Не удалять полностью Flow-слой и существующую диагностику, если это не продиктовано результатами исследования (предпочтителен вариант архитектурного разведения режимов).
- Не вносить изменения в общую DNS-логику AuditRunner/Tests (решается отдельно в рамках DNS-тестов).

**Оценка**: MEDIUM (несколько подзадач под Research/Planning/Coding/QA)

---

## Схема работы агентов

(без изменений, используется стандартная схема из шаблона TASK_TEMPLATE)

- [PURPLE] Task Owner: текущий файл `agents/task_owner/current_task.md` описывает задачу.
- [RED] Research Agent: уточняет, какие именно части `WinDivertBypassManager`, `TrafficAnalyzer` и LiveTesting сейчас задействованы, и фиксирует риски.
- [BLUE] Planning Agent: на основе deep-dive и findings разбивает работу на подзадачи (например: архитектурное разведение Flow/Network, стабилизация RST-блокера, таргетинг TLS-фрагментации, минимальный DNS-редирект).
- [GREEN] Coding Agent: реализует подзадачи по плану, не выходя за границы указанных файлов.
- [YELLOW] QA Agent: проверяет, что критерии приёмки из секции "Желаемый результат" выполняются.
- [CYAN] Delivery Agent: оформляет changelog и git commit.

---

## Заметки

- Основной источник требований и контекста: `docs/bypass_architecture_deep_dive.md` и `docs/bypass_strategy_todo.md` (нужно свериться и актуализировать план).
- При планировании важно заранее зафиксировать, используем ли подход A (жёсткое отключение Flow во время active bypass) или C (разведение приоритетов и фильтров), и какую комбинацию будем пробовать первой на тестовом провайдере.
- Желательно предусмотреть детализированное логирование на уровне соединений (correlation ID), но это может быть отдельной подзадачей, если не влезет в первую итерацию.

# [PURPLE] Task Owner: End-to-End Testing + UX Polish для Exe-scenario

**Дата:** 20 ноября 2025 г.  
**Ветка:** feature/wpf-new-migration  
**Статус:** Формирование задачи

---

## Проблема

**Краткое описание**:
Exe-scenario (Stage 1→2→3) работает функционально, но имеет проблемы с UX: кнопки не блокируются во время выполнения операций, модальные MessageBox окна прерывают workflow, нет визуальной обратной связи о прогрессе. Нужен плавный, непрерывный flow без "спотыканий".

**Как проявляется**:
```
1. Запускаем Stage 1 "Analyze Traffic" → кнопка остаётся активной (можно нажать повторно)
2. После Stage 1 → MessageBox "Перейти к Stage 2?" → прерывает flow (требует клика)
3. После Stage 2 → MessageBox "Перейти к Stage 3?" → ещё одно прерывание
4. Во время длительных операций (30 сек capture) → нет индикации прогресса
5. Можно нажать "Диагностика" пока уже идёт другая операция
6. Нет кнопки "Сбросить" для начала нового анализа
```

**Контекст**:
- Критичность: **HIGH** (блокер для комфортного использования)
- Текущий код: `ViewModels/MainViewModel.cs` (1547 строк), `MainWindow.xaml`
- Проблемные места: `AnalyzeTrafficCommand`, `DiagnoseCommand`, `ApplyBypassCommand`

---

## Желаемый результат (Definition of Done)

После выполнения:

1. **Кнопки блокируются корректно:**
   - Во время Stage 1/2/3 все команды кроме "Остановить" заблокированы
   - `CanExecute` проверяет `IsRunning` флаг для всех команд
   - `CommandManager.InvalidateRequerySuggested()` вызывается после изменения состояния

2. **Модальные окна заменены на автоматический flow:**
   - Убрать MessageBox "Перейти к Stage 2?" → автоматически запускать Stage 2 после Stage 1
   - Убрать MessageBox "Перейти к Stage 3?" → автоматически запускать Stage 3 после Stage 2
   - Оставить ТОЛЬКО критичные MessageBox (ошибки, предупреждения об admin правах)

3. **Прогресс индикация улучшена:**
   - Stage 1: показывать "Захвачено N соединений..." каждые 2 секунды
   - Stage 2: показывать "Тестирование цели X из Y..."
   - Stage 3: показывать "Применение DNS fix..." / "Активация WinDivert..."
   - Процент выполнения для каждой стадии (0-100%)

4. **Кнопка "Сбросить" добавлена:**
   - Появляется после завершения любой Stage
   - Очищает _capturedProfile, _exePath, TestResults
   - Сбрасывает Stage1/2/3Complete флаги
   - Возвращает UI в начальное состояние

5. **Ручное тестирование задокументировано:**
   - Чеклист из 15-20 шагов для полного E2E теста
   - Описание ожидаемого поведения на каждом шаге
   - Файл `docs/e2e_test_checklist.md` создан

Критерии приёмки:
- ✅ Нельзя запустить две операции одновременно (команды блокируются)
- ✅ Workflow Stage 1→2→3 выполняется без MessageBox прерываний
- ✅ Прогресс показывается в реальном времени (не indeterminate spinner)
- ✅ Кнопка "Сбросить" работает и возвращает UI в начальное состояние
- ✅ E2E checklist выполнен с TestNetworkApp.exe без ошибок
- ✅ Нет регрессий: профильная диагностика (Star Citizen) работает как раньше

---

## Ограничения

**Технические**:
- .NET 9, WPF + MaterialDesign
- Async/await + CancellationToken для всех длительных операций
- MVVM pattern: вся логика в MainViewModel, UI binding в XAML
- Обратная совместимость: **ДА** (профильный сценарий не трогать)

**Что НЕ делать**:
- НЕ переписывать TrafficAnalyzer.cs (захват трафика работает)
- НЕ менять логику Stage 1/2/3 (только UX улучшения)
- НЕ трогать CapturedTargetsWindow.xaml (окно результатов отдельное)
- НЕ добавлять автоматические тесты (будет использоваться ручное тестирование)
- НЕ переводить на английский (весь UI на русском)

**Оценка**: **MEDIUM** (6-8 подзадач)

**Рекомендуемая модель для ВСЕХ агентов**: **Claude Sonnet 4.5**

---

## Схема работы агентов

**ВАЖНО**: Каждый агент работает в ОТДЕЛЬНОМ контексте (новый чат/сессия)!
- Агенты НЕ видят друг друга
- Связь только через файлы: `current_task.md`, `findings.md`, `plan.md`, `test_report.md`, `changelog.md`
- Task Owner координирует работу, передавая результаты между агентами

**Цветовая маркировка агентов**:
```
[PURPLE] - Task Formulation / Task Owner
[RED]    - Research Agent
[BLUE]   - Planning Agent
[GREEN]  - Coding Agent
[YELLOW] - QA Agent
[CYAN]   - Delivery Agent
```

**Поток работы**:
```
[0] [PURPLE] Task Owner            → current_task.md (этот файл)
                         ↓
[1] [RED] Research Agent           → Исследование кода → findings.md
                         ↓
[2] [BLUE] Planning Agent          → Детальный план → plan.md
                         ↓
[3] [GREEN] Coding Agent           → Реализация (N раз, быстрая модель)
                         ↓
[4] [YELLOW] QA Agent              → Тестирование → test_report.md
                         ↓
[5] [CYAN] Delivery Agent          → Коммит + changelog
```

---

## [1] [RED] Research Agent

**Статус**: [ ] TODO / [ ] IN PROGRESS / [ ] DONE

**Агент работает в отдельном контексте!** Он НЕ видит этот файл и предыдущую переписку.

**Входные файлы** (агент должен прочитать сам):
- `agents/task_owner/current_task.md` - полное описание задачи

**Выходной файл** (агент должен создать):
- `agents/research_agent/findings.md`

**Промпт для нового чата**:
```
Ты [RED] Research Agent. Работаешь в изолированном контексте. Используй модель Claude Sonnet 4.5.

Прочитай файл agents/task_owner/current_task.md и исследуй проблему:
1. Найди все затронутые файлы и компоненты
2. Изучи текущую реализацию команд (AnalyzeTrafficCommand, DiagnoseCommand, ApplyBypassCommand)
3. Найди где используются MessageBox и как организован workflow
4. Изучи как реализован IsRunning флаг и блокировка команд
5. Выяви риски и зависимости

Создай файл agents/research_agent/findings.md со структурой:

## Затронутые файлы
[список с описанием что делает каждый]

## Текущая реализация
[как работают команды, где MessageBox, как блокируются кнопки]

## Проблемы в текущей реализации
[что именно не работает, почему кнопки не блокируются]

## Риски и зависимости
[что может сломаться, от чего зависит]

## Рекомендации для Planning Agent
[что важно учесть при планировании]
```

**После завершения**: Task Owner переходит к [2]

---

## [2] [BLUE] Planning Agent

**Статус**: [ ] TODO / [ ] IN PROGRESS / [ ] DONE

**Агент работает в отдельном контексте!**

**Входные файлы** (агент должен прочитать сам):
- `agents/task_owner/current_task.md` - описание задачи
- `agents/research_agent/findings.md` - результаты исследования от [RED] агента

**Выходной файл** (агент должен создать):
- `agents/planning_agent/plan.md`

**Промпт для нового чата**:
```
Ты [BLUE] Planning Agent. Работаешь в изолированном контексте. Используй модель Claude Sonnet 4.5.

Прочитай:
1. agents/task_owner/current_task.md (задача)
2. agents/research_agent/findings.md (результаты исследования)

Создай детальный план в agents/planning_agent/plan.md:

ВАЖНО: 
- Каждая подзадача = 1-2 файла максимум
- Группируй связанные изменения
- Минимизируй количество подзадач без потери качества
- НЕ давай готовый код, только описание что нужно сделать

Формат каждой подзадачи:

## Подзадача N: [Название]
- Файлы: path/to/file.cs, path/to/file.xaml
- Описание: [что именно изменить, какую логику добавить/удалить/заменить]
- Зависимости: нет / после подзадачи M
- Риски: [если есть]

В конце добавь секцию:

## Итого
- Количество подзадач: N
- Порядок выполнения: [последовательно / можно параллельно задачи X,Y,Z]
- Основные риски: [общие риски]
```

**После завершения**: Task Owner переходит к [3]

---

## [3] [GREEN] Coding Agent (повторить N раз)

**Статус по подзадачам**:
- [ ] Подзадача 1
- [ ] Подзадача 2
- [ ] Подзадача 3
- [ ] ...

**Каждый Coding Agent = новый контекст!** Они НЕ видят работу предыдущих Coding Agent.

**Входные файлы** (агент должен прочитать сам):
- `agents/planning_agent/plan.md` - читает только свою подзадачу N
- Файлы кода, указанные в подзадаче

**Выходной файл** (агент должен изменить):
- Файлы, указанные в подзадаче

**Промпт для каждой подзадачи N**:
```
Ты [GREEN] Coding Agent #N. Работаешь в изолированном контексте. Используй модель Claude Sonnet 4.5.

1. Прочитай agents/planning_agent/plan.md
2. Найди в нём подзадачу N: [НАЗВАНИЕ ПОДЗАДАЧИ]
3. Прочитай указанные файлы
4. Внеси изменения согласно описанию в подзадаче
5. Убедись что синтаксис правильный

НЕ создавай промежуточные файлы!
Результат: изменённый код, готовый к тестированию.
```

**Повторить для каждой подзадачи** из `plan.md`

**После завершения всех подзадач**: Task Owner переходит к [4]

---

## [4] [YELLOW] QA Agent

**Статус**: [ ] TODO / [ ] IN PROGRESS / [ ] DONE

**Агент работает в отдельном контексте!**

**Входные файлы** (агент должен прочитать сам):
- `agents/task_owner/current_task.md` - критерии приёмки из секции "Желаемый результат"
- Изменённые файлы кода (для проверки)

**Выходной файл** (агент должен создать):
- `agents/qa_agent/test_report.md`

**Промпт для нового чата**:
```
Ты [YELLOW] QA Agent. Работаешь в изолированном контексте. Используй модель Claude Sonnet 4.5.

1. Прочитай agents/task_owner/current_task.md (секция "Желаемый результат")
2. Запусти `dotnet build -c Debug` для проверки компиляции
3. Если есть GUI изменения: запусти `dotnet run` и проверь визуально
4. Проверь каждый критерий приёмки
5. Проверь на регрессии (старые сценарии работают)
6. Создай E2E test checklist в docs/e2e_test_checklist.md с 15-20 шагами

Создай agents/qa_agent/test_report.md в формате:

## Результаты тестирования
[список проверенных критериев с PASS/FAIL]

## Найденные проблемы
[список проблем или 'Проблем не найдено']

## E2E Test Checklist
[краткое описание созданного чеклиста в docs/]

## Рекомендации
[нужны ли фиксы, можно ли коммитить]
```

**Если есть проблемы**: Task Owner возвращается к [3] и создаёт Coding Agent для фиксов

**Если OK**: Task Owner переходит к [5]

---

## [5] [CYAN] Delivery Agent

**Статус**: [ ] TODO / [ ] IN PROGRESS / [ ] DONE

**Агент работает в отдельном контексте!**

**Входные файлы** (агент должен прочитать сам):
- `agents/task_owner/current_task.md` - название задачи
- `agents/planning_agent/plan.md` - все подзадачи для changelog

**Выходные файлы** (агент должен создать/изменить):
- `agents/delivery_agent/changelog.md` - добавить новую запись
- Git commit

**Промпт для нового чата**:
```
Ты [CYAN] Delivery Agent. Работаешь в изолированном контексте. Используй модель Claude Sonnet 4.5.

1. Прочитай agents/task_owner/current_task.md и agents/planning_agent/plan.md
2. Создай краткий changelog (что изменилось, зачем)
3. Добавь запись в agents/delivery_agent/changelog.md
4. Создай git commit с сообщением:

[Краткое название задачи]

[Описание изменений 2-3 предложения]

Основные изменения:
- [изменение 1]
- [изменение 2]
- [изменение 3]

Generated with AI Assistant

5. (Опционально) Обнови README.md если изменился функционал
```

**После завершения**: Задача готова!

---

## Заметки

**Ключевые области для исследования:**
- `ViewModels/MainViewModel.cs` - команды, IsRunning флаг, workflow
- `MainWindow.xaml` - UI bindings, кнопки, прогресс индикаторы
- `Utils/TrafficAnalyzer.cs` - возможность добавить progress callback
- RelayCommand implementation - как работает CanExecute

**Важно:**
- Агенты должны сами найти все проблемные места в коде
- Агенты должны сами разработать архитектуру решения
- Task Owner только координирует, НЕ пишет код
- Все агенты используют Claude Sonnet 4.5

# [PURPLE] Task Owner: Live Testing Pipeline Refactoring

**Дата:** 22 ноября 2025 г.
**Ветка:** feature/live-testing-pipeline
**Статус:** В работе

---

## Выполненные подзадачи

### C1. Убрать Stage-модель из GUI
**Статус:** COMPLETED
**Изменения:**
1.  **ViewModels/MainViewModel.cs**:
    -   Добавлен единый entry-point `RunDiagnosticPipelineCommand` и метод `RunDiagnosticPipelineAsync`.
    -   Добавлены свойства `DiagnosticStatus` и `IsDiagnosticRunning` для управления состоянием единого пайплайна.
    -   Удалена автоматическая цепочка вызовов (`_ = RunStage...`) из методов `RunStage1AnalyzeTrafficAsync` и `RunStage2DiagnoseAsync`. Теперь оркестрация выполняется в `RunDiagnosticPipelineAsync`.
    -   Сохранены существующие методы этапов для обратной совместимости и использования внутри пайплайна.

2.  **MainWindow.xaml**:
    -   Удалены отдельные карточки для Stage 1, Stage 2, Stage 3.
    -   Интерфейс Exe-сценария заменён на упрощённую панель с одной кнопкой "Запустить диагностику".
    -   Добавлена визуализация статуса диагностики и спиннер активности.
    -   Сохранены настройки (Live Testing, Auto Bypass) и кнопка сброса.

**Результат:**
GUI переведен на одноступенчатую модель запуска. Пользователь видит одну кнопку, которая запускает последовательное выполнение всех этапов диагностики.


