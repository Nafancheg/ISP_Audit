# План — TLS Fragment/Disorder

## Подзадача 1. Консолидация архитектуры TLS bypass на сервисе
- Цель: оставить единственный источник правды: события/метрики/автокоррекция через сервис [Bypass/TlsBypassService.cs](Bypass/TlsBypassService.cs); [ViewModels/BypassController.cs](ViewModels/BypassController.cs) становится тонким прокси.
- Действия: сопоставить UI-флаги Fragment/Disorder/Fake/DropRST/DoH/AutoAdjust с опциями сервиса; убедиться, что сервис держит пресеты (Стандарт/Умеренный/Агрессивный/Профиль) и AutoAdjust. При необходимости расширить TlsBypassOptions и события StateChanged/MetricsUpdated/VerdictChanged.
- Обновить регистрацию фильтра: TlsBypassService сам управляет [Core/Traffic/Filters/BypassFilter.cs](Core/Traffic/Filters/BypassFilter.cs); убрать прямую регистрацию из контроллера.
- Риски: несовпадение полей профиля ([Bypass/BypassProfile.cs](Bypass/BypassProfile.cs)), двойная инициализация фильтра; нужно аккуратно мигрировать, не ломая applyProfile.

## Подзадача 2. Интеграция UI/оркестратора с сервисом и отказ от таймера контроллера
- Цель: UI получает метрики/вердикт из событий сервиса, не через DispatcherTimer.
- Действия: подписать BypassController на MetricsUpdated/VerdictChanged/StateChanged сервиса; удалить/выключить локальный таймер. Обновить вычисление цветов/логики карточек на основе вердикта сервиса.
- Обновить преэмптивное включение: [ViewModels/DiagnosticOrchestrator.cs](ViewModels/DiagnosticOrchestrator.cs) показывает статус auto-bypass (включено/применено/ошибка) и итог метрик; связать с сервисом вместо прямых вызовов EnablePreemptiveBypassAsync.
- Риски: гонки при Dispose/перезапуске сервиса; учитывать ConfigureAwait(false) в сервисных вызовах.

## Подзадача 3. UX-вердикт «работает/не работает» + состояния «нет данных»
- Цель: снизить шум карточки TLS: явные статусы «нет TLS трафика/короткий ClientHello/порт ≠443», «обход активен, но нет фрагментаций», «обход работает/не работает», плюс next steps.
- Действия: расширить вердикт сервиса или маппинг в UI на новые состояния; выводить краткий текст и подсказку (снизить threshold/сменить пресет/выключить Drop RST). Добавить отображение LastFragmentPlan и активного пресета.
- Риски: не захламить UI; соблюдать правило показа карточек только при проблемах/нет данных.

## Подзадача 4. Поведение пресетов и автокоррекции
- Цель: единая логика AutoAdjust (минимальный чанк, зелёный таймер) в сервисе; UI только включает флаг.
- Действия: перенести/свести правила автокоррекции из контроллера в сервис (RST>2x → minChunk=4; green>30s → ослабление). Обновить сохранение/загрузку профиля ([Bypass/BypassProfile.cs](Bypass/BypassProfile.cs)), отображение текущего threshold/мин-чанка в UI.
- Риски: регрессия агрессивного пресета; убедиться, что Drop RST/Disorder/Fake сохраняются в профиль.

## Подзадача 5. Рекомендации и связь с тестером/классификатором
- Цель: увязать рекомендации из [Utils/LiveTestingPipeline.cs](Utils/LiveTestingPipeline.cs) и [Core/Modules/StandardBlockageClassifier.cs](Core/Modules/StandardBlockageClassifier.cs) с включением сервисных опций без лог-спама.
- Действия: показывать в UI кнопку/тоггл «применить рекомендованное» → включает нужные опции сервиса; исключать уже активные стратегии; учитывать ограничения [Core/Modules/StandardHostTester.cs](Core/Modules/StandardHostTester.cs) (hostname-only TLS) в подсказках.
- Риски: не включать стратегию дважды; не ломать старый профиль.

## Подзадача 6. Документация
- Обновить [docs/phase2_plan.md](docs/phase2_plan.md) пункт 2.6 под фактическое состояние (сервис + UI прокси, метрики, вердикты, автокоррекция, пресеты, ограничения TLS 443/ClientHello).
- Зафиксировать архитектуру в [ARCHITECTURE_CURRENT.md](ARCHITECTURE_CURRENT.md) (единый TlsBypassService, события, привязка к UI/оркестратору) и разрыв, если что-то решено оставить временно.
- Прописать актуальные риски/фидбек/UX решения в [docs/full_repo_audit_v2.md](docs/full_repo_audit_v2.md).

## Подзадача 7. Проверки и UX-фидбек
- Для QA: ручной прогон с интенсивным трафиком (несколько вкладок браузера), наблюдение за шумом карточек и вердиктом, сбор логов метрик сервиса; dotnet build -c Debug.
- Зафиксировать результаты в agents/qa_agent/test_report.md, отметить пользовательский фидбек по понятности статуса обхода и next steps.

## Порядок выполнения
1) Подзадача 1 → 2 (консолидация + интеграция UI). 
2) Затем 3–5 (UX/автокоррекция/рекомендации), можно параллельно 3 и 4 после завершения 2. 
3) После кода — 6 (документация) и 7 (проверки).
