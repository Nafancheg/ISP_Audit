# [BLUE] Planning Agent: Детальный план реализации

**Дата**: 2025-10-31
**Статус**: READY

---

## ЧАСТЬ 1: Архитектура профилей + Star Citizen

### Подзадача 1: Расширить модели данных + создать профиль

**Файлы**:
- `TargetModels.cs` (добавить поля Critical, FallbackIp, структуру GameProfile)
- `Profiles/StarCitizen.json` (создать новый файл)

**Описание**:
1. В `TargetModels.cs`:
   - Добавить в класс `TargetDefinition` два новых поля: `Critical` (bool) и `FallbackIp` (string, nullable)
   - Создать новый класс `GameProfile` с полями: Name, TestMode, ExePath, Targets (список TargetDefinition)

2. Создать новый файл `Profiles/StarCitizen.json`:
   - Убрать порталы: `robertsspaceindustries.com`, `accounts.`, `api.`, `cdn.`
   - Оставить launcher: `install.robertsspaceindustries.com` (TCP 80, 443, 8000-8003) — пометить как Critical
   - Добавить AWS EU: `ec2.eu-central-1.amazonaws.com` (TCP 8000-8003) — Critical, с FallbackIp
   - Добавить AWS US: `ec2.us-east-1.amazonaws.com` (TCP 8000-8003) — некритичный, с FallbackIp
   - Оставить Vivox: `viv.vivox.com` (TCP 443, UDP 3478) — Critical
   - Оставить S3 endpoints для CDN (некритичные, без FallbackIp)

**Зависимости**: нет


**Риски**: изменение структуры TargetDefinition может потребовать миграции старых JSON

---

### Подзадача 2: Обновить загрузку целей (ProfileManager)

**Файлы**:
- `Config.cs` (добавить методы LoadGameProfile, GetActiveProfile)

**Описание**:
1. В `Config.cs` добавить:
   - Статическое свойство `ActiveProfile` для хранения текущего активного профиля
   - Метод `LoadGameProfile(profileName)` — загружает JSON файл из папки Profiles/, десериализует в GameProfile
   - Метод `SetActiveProfile(profileName)` — устанавливает активный профиль (по умолчанию "StarCitizen")

2. В `Program.cs`:
   - После вызова `Config.Load()` добавить вызов `Config.SetActiveProfile("StarCitizen")` для загрузки профиля при старте

**Зависимости**: после подзадачи 1

**Риски**: ошибка при отсутствии файла профиля (нужна обработка исключений)

---

### Подзадача 3: Обновить AuditRunner (early-exit для Critical целей)

**Файлы**:
- `AuditRunner.cs` (изменить логику на строках ~85-95)

**Описание**:
1. Найти в `AuditRunner.cs` секцию после DNS теста, где происходит early-exit если `target.DnsResult.Addresses.Count == 0`
2. Изменить логику:
   - Если DNS пуст И цель критичная (Critical=true) И есть FallbackIp → добавить fallback IP в список адресов, продолжить тестирование
   - Если DNS пуст И цель НЕкритичная ИЛИ нет FallbackIp → пропустить тестирование этой цели (текущее поведение)
   - Добавить в StatusText информацию об использовании fallback IP

**Зависимости**: после подзадачи 1

**Риски**: нет

---

### Подзадача 4: Обновить ReportWriter (вердикт с учётом Critical)

**Файлы**:
- `Output/ReportWriter.cs` (метод определения playable)

**Описание**:
1. Найти метод в `ReportWriter.cs`, который определяет статус `playable` (вероятно, в методе `BuildSummary()`)
2. Изменить логику определения playable:
   - Получить список критичных целей из `Config.ActiveProfile.Targets.Where(t => t.Critical)`
   - Если хотя бы одна критичная цель имеет статус "FAIL" → `playable = "NO"`
   - Если все критичные цели доступны, но есть недоступные некритичные → `playable = "MAYBE"`
   - Если все критичные цели доступны → `playable = "YES"`
3. Учесть что старые тесты могут не иметь поля Critical (default = false)

**Зависимости**: после подзадачи 2

**Риски**: нужно учесть что некоторые старые тесты могут не иметь поля Critical (default = false)

---

### Подзадача 5: Обновить GUI (отображение профиля)

**Файлы**:
- `MainWindow.xaml` (добавить TextBlock для профиля, TextBox для хоста, TextBox для EXE)
- `MainWindow.xaml.cs` (инициализация текста профиля)

**Описание**:
1. В `MainWindow.xaml`:
   - Добавить TextBlock для отображения активного профиля с текстом "Активный профиль: {название профиля}"
   - Добавить TextBox с placeholder "Тест хоста" (пока disabled, для будущего функционала)
   - Добавить TextBox с placeholder "EXE файл игры" (пока disabled, для будущего функционала)
   - Разместить эти элементы в подходящем месте разметки (вероятно, в верхней части окна)

2. В `MainWindow.xaml.cs`:
   - В конструкторе после загрузки профиля установить текст TextBlock из `Config.ActiveProfile.Name`
   - Обработать случай когда профиль не загружен (показать "Не загружен")

**Зависимости**: после подзадачи 2

**Риски**: нужно найти подходящее место в разметке (вероятно, в верхней части окна)

---

## ЧАСТЬ 2: Упрощение DNS + кнопки Fix

### Подзадача 6: Упростить DnsTest (статус только по System DNS)

**Файлы**:
- `Tests/DnsTest.cs` (изменить логику определения статуса)

**Описание**:
1. Найти в `Tests/DnsTest.cs` метод, который определяет `DnsStatus` (вероятно, называется `DetermineDnsStatus` или аналогично)
2. Упростить логику определения статуса — использовать ТОЛЬКО System DNS:
   - Если System DNS пустой (не вернул адресов) → статус `DNS_FILTERED`
   - Если System DNS вернул мусорные адреса (0.0.0.0, 127.x.x.x) → статус `DNS_BOGUS`
   - Если System DNS вернул нормальные публичные адреса → статус `OK`
3. DoH и Google DNS оставить только для информации (выводить в отчёт), но НЕ использовать в логике определения статуса
4. Проверить что VPN-aware логика не сломана

**Зависимости**: нет (независимая от Части 1)

**Риски**: может изменить поведение для VPN-профилей (проверить VPN-aware логику)

---

### Подзадача 7: Добавить методы DNS Fix/Reset + проверка доступности

**Файлы**:
- `MainWindow.xaml.cs` (добавить методы FixDnsButton_Click, ResetDnsButton_Click, CheckDohProviderAvailability)

**Описание**:
1. Добавить в `MainWindow.xaml.cs` метод `CheckDohProviderAvailability`:
   - Проверять доступность нескольких DoH провайдеров: Cloudflare (1.1.1.1), Google (8.8.8.8), Quad9 (9.9.9.9)
   - Для каждого провайдера делать HTTPS запрос к DoH endpoint с таймаутом 5 секунд
   - Возвращать первый доступный провайдер (IP и URL) или null если все недоступны

2. Добавить метод `FixDnsButton_Click`:
   - Вызвать CheckDohProviderAvailability для определения доступного провайдера
   - Если провайдер найден → применить через команды netsh (установить DNS, включить DoH)
   - Запустить netsh с правами администратора (UAC запрос)
   - Показать MessageBox с результатом операции
   - Определить имя активного сетевого адаптера для команды netsh

3. Добавить метод `ResetDnsButton_Click`:
   - Восстановить DHCP DNS через команды netsh
   - Отключить DoH через netsh
   - Запустить с правами администратора (UAC запрос)
   - Показать MessageBox с результатом

**Зависимости**: нет (независимая от других подзадач)

**Риски**: требуется определить имя активного сетевого адаптера (может быть несколько интерфейсов)

---

### Подзадача 8: Добавить кнопки DNS Fix в GUI

**Файлы**:
- `MainWindow.xaml` (добавить Button "ИСПРАВИТЬ DNS" и Button "ВЕРНУТЬ DNS")

**Описание**:
1. Найти в `MainWindow.xaml` секцию с результатами DNS теста (вероятно, рядом с TextBlock, показывающим DNS статус)
2. Добавить 2 кнопки в стиле MaterialDesign:
   - Button "🔧 ИСПРАВИТЬ DNS" с обработчиком FixDnsButton_Click
   - Button "↩️ ВЕРНУТЬ DNS" с обработчиком ResetDnsButton_Click
   - Изначально обе кнопки должны быть скрыты (Visibility="Collapsed")

3. В `MainWindow.xaml.cs` добавить логику видимости кнопок:
   - Показывать "ИСПРАВИТЬ DNS" только когда DNS статус = `DNS_FILTERED` или `DNS_BOGUS`
   - Показывать "ВЕРНУТЬ DNS" только после успешного применения Fix (сохранить флаг в переменной)
   - Скрывать обе кнопки если DNS статус = OK

**Зависимости**: после подзадачи 7 (методы должны существовать)

**Риски**: нужно найти правильное место в разметке (возможно, StackPanel или Grid)

---

## Итого

**Количество подзадач**: 8

**Порядок выполнения**:
- **Часть 1** (подзадачи 1-5): последовательно (1 → 2 → 3,4,5 параллельно)
  - Подзадача 1 → создание структур (блокирует остальные)
  - Подзадача 2 → загрузка профиля (блокирует 4, 5)
  - Подзадачи 3, 4, 5 → МОЖНО параллельно (не зависят друг от друга)

- **Часть 2** (подзадачи 6-8): последовательно (6 независимо, 7 → 8)
  - Подзадача 6 → МОЖНО параллельно с Частью 1 (независимая)
  - Подзадача 7 → создание методов (блокирует 8)
  - Подзадача 8 → добавление UI (зависит от 7)

**Оптимальная последовательность для экономии API**:
```
1. Подзадача 1 (структуры + JSON)
2. Подзадача 2 (загрузка)
3. Подзадачи 3 + 4 + 5 + 6 (параллельно, если возможно)
4. Подзадача 7 (DNS методы)
5. Подзадача 8 (DNS GUI)
```

**Основные риски**:
1. **Обратная совместимость**: старый `star_citizen_targets.json` больше не используется → нужна миграция
2. **DNS изменения**: требуют прав администратора → может не работать без UAC
3. **Fallback IP**: хардкод IP AWS серверов → могут измениться (нужен мониторинг)
4. **DoH проверка**: HTTPS запросы могут таймаутиться → нужен fallback на "нет доступных провайдеров"
5. **Сетевые адаптеры**: определение активного адаптера может быть неоднозначным (VPN, виртуальные адаптеры)

**Время выполнения** (оценка):
- Coding: ~45-60 минут (8 подзадач × 5-8 минут)
- QA: ~15-20 минут
- Delivery: ~5 минут
- **Итого**: ~1.5 часа

**Экономия API лимитов**:
- Использование быстрых моделей (GPT-4o-mini / Haiku) для всех подзадач
- Группировка связанных изменений (подзадача 1 = 2 файла вместо 2 подзадач)
- Минимизация количества подзадач: 8 вместо 10-12

---

**Дата создания**: 2025-10-31  
**Статус**: ✅ Готов к выполнению
