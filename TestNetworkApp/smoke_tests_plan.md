# ISP_Audit v3.0 — План Smoke-тестов

**Дата:** 18.12.2025
**Цель:** Быстрая проверка критического функционала без полного GUI запуска
**Время выполнения:** ~5-10 минут на полный набор

---

## 1. Infrastructure Layer (Инфраструктура)

### 1.1 WinDivert Driver
**Test ID:** `INFRA-001`
**Что проверяет:** Загрузка драйвера WinDivert
**Для чего:** Без драйвера вся система не работает
**Критерий успеха:** Драйвер загружается без ошибок, возвращает handle
**Входные данные:** Нет
**Ожидаемый результат:** `TrafficEngine.Initialize()` возвращает `true`

**Test ID:** `INFRA-002`
**Что проверяет:** Регистрация фильтра в TrafficEngine
**Для чего:** Проверка механизма добавления/удаления фильтров
**Критерий успеха:** Фильтр добавляется в список активных
**Входные данные:** Dummy-фильтр
**Ожидаемый результат:** Фильтр присутствует в `ActiveFilters`

**Test ID:** `INFRA-003`
**Что проверяет:** Порядок выполнения фильтров (пассивные → модифицирующие)
**Для чего:** Критично для корректного снятия метрик до модификации
**Критерий успеха:** `TrafficMonitorFilter` вызывается раньше `BypassFilter`
**Входные данные:** Два фильтра с разными приоритетами
**Ожидаемый результат:** Счетчики вызовов подтверждают порядок

### 1.2 Права доступа
**Test ID:** `INFRA-004`
**Что проверяет:** Наличие прав администратора
**Для чего:** WinDivert требует UAC elevation
**Критерий успеха:** Текущий процесс имеет Admin-роль
**Входные данные:** Нет
**Ожидаемый результат:** `WindowsPrincipal.IsInRole(Administrator) == true`

### 1.3 Кодировки
**Test ID:** `INFRA-005`
**Что проверяет:** Регистрация CP866 (OEM) для `tracert`
**Для чего:** Без этого русские символы в tracert превращаются в кракозябры
**Критерий успеха:** `Encoding.GetEncoding(866)` не выбрасывает исключение
**Входные данные:** Нет
**Ожидаемый результат:** Кодировка доступна после `Encoding.RegisterProvider`

**Test ID:** `INFRA-006`
**Что проверяет:** Устойчивость TrafficEngine к мутациям списка фильтров во время обработки пакета
**Для чего:** Защита от редкого падения `Collection was modified; enumeration operation may not execute`
**Критерий успеха:** Реэнтрантные Register/Remove во время обработки не приводят к исключению
**Входные данные:** Dummy TCP пакет + фильтр, который меняет список фильтров в своём `Process`
**Ожидаемый результат:** Обработка выполняется без падения

**Test ID:** `INFRA-007`
**Что проверяет:** Устойчивость TrafficEngine к конкурентному churn списка фильтров (параллельные Register/Remove) во время обработки
**Для чего:** Стресс‑вариант защиты от `Collection was modified` и прочих race‑эффектов вокруг списка фильтров
**Критерий успеха:** Параллельные Register/Remove и `ProcessPacketForSmoke` выполняются без исключений
**Входные данные:** Dummy TCP пакет + параллельный цикл churn фильтра по имени
**Ожидаемый результат:** Обработка выполняется без падения

**Test ID:** `INFRA-008`
**Что проверяет:** Устойчивость TrafficEngine к быстрому Apply/Disable bypass во время активной обработки пакетов
**Для чего:** Приближенный к реальности сценарий (пользователь кликает Apply/Disable во время диагностики) — не должен приводить к исключениям/зависаниям
**Критерий успеха:** Параллельные `ApplyTlsOptionsAsync`/`DisableTlsAsync` и `ProcessPacketForSmoke` выполняются без падения
**Входные данные:** Dummy TCP пакет + цикл Apply/Disable через `BypassStateManager` (без WinDivert)
**Ожидаемый результат:** Обработка выполняется без исключений, тест завершается за ограниченное время

**Test ID:** `INFRA-009`
**Что проверяет:** Устойчивость к конкурентным обновлениям execution-plane данных (DecisionGraphSnapshot + UDP/443 targets) во время обработки пакетов
**Для чего:** Закрывает класс проблем «меняем snapshot/targets, пока фильтр читает их в hot path»
**Критерий успеха:** Частые переключения snapshot/targets параллельно `ProcessPacketForSmoke` не приводят к исключениям
**Входные данные:** BypassFilter + reflection вызовы `SetDecisionGraphSnapshot`/`SetUdp443DropTargetIps`
**Ожидаемый результат:** Обработка выполняется без падения

---

## 2. Core Pipeline (Конвейер обработки)

### 2.1 Traffic Collection
**Test ID:** `PIPE-001`
**Что проверяет:** Захват SYN-пакетов через ConnectionMonitorService
**Для чего:** Проверка, что система видит новые соединения
**Критерий успеха:** События соединений публикуются при подключении
**Входные данные:** Открытие TCP-соединения на известный хост
**Ожидаемый результат:** `ConnectionMonitor` вызывает callback с `remote_endpoint`

**Test ID:** `PIPE-002`
**Что проверяет:** PID-фильтрация в TrafficCollector
**Для чего:** Убедиться, что трафик фильтруется по целевому процессу
**Критерий успеха:** Пакеты от других процессов игнорируются
**Входные данные:** Трафик от 2+ процессов, фильтр по одному PID
**Ожидаемый результат:** В пайплайн попадают только пакеты целевого PID

**Test ID:** `PIPE-003`
**Что проверяет:** SNI-парсинг из TLS ClientHello
**Для чего:** Извлечение доменного имени для отображения в UI
**Критерий успеха:** SNI извлекается из цельного и фрагментированного ClientHello
**Входные данные:** TLS ClientHello для `example.com` (цельный и разбитый на 2 сегмента)
**Ожидаемый результат:** `DnsParserService` возвращает `example.com`

**Test ID:** `PIPE-004`
**Что проверяет:** Корреляция SNI с PID через remote endpoint
**Для чего:** Гейтирование SNI по целевому процессу (без PID в WinDivert Network Layer)
**Критерий успеха:** SNI проходит в пайплайн только если endpoint совпадает с отслеживаемым PID
**Входные данные:** SNI-событие для хоста + события соединений с разными PID
**Ожидаемый результат:** Orchestrator пропускает только релевантные SNI

### 2.2 Filtering & Validation
**Test ID:** `PIPE-005`
**Что проверяет:** UnifiedTrafficFilter отбрасывает loopback
**Для чего:** Не создавать карточки для 127.0.0.1
**Критерий успеха:** Локальные адреса не попадают в UI
**Входные данные:** `127.0.0.1`, `::1`
**Ожидаемый результат:** Фильтр возвращает `false`

**Test ID:** `PIPE-006`
**Что проверяет:** NoiseHostFilter применяется только на этапе отображения
**Для чего:** Не терять сигнал на браузерных/CDN-сценариях при pre-check
**Критерий успеха:** Хост тестируется, но не показывается в UI если Status=OK
**Входные данные:** `fonts.googleapis.com` (успешное соединение)
**Ожидаемый результат:** Тест выполнен, но карточка не создана

**Test ID:** `PIPE-007`
**Что проверяет:** Дедупликация хостов в InMemoryBlockageStateStore
**Для чего:** Не тестировать один хост многократно за сессию
**Критерий успеха:** Повторная проверка игнорируется
**Входные данные:** 2 события для `example.com` подряд
**Ожидаемый результат:** Только первое попадает в тестер

### 2.3 Testing
**Test ID:** `PIPE-008`
**Что проверяет:** DNS-резолв через StandardHostTester
**Для чего:** Проверка базовой доступности домена
**Критерий успеха:** Возвращаются IP-адреса для существующего домена
**Входные данные:** `google.com`
**Ожидаемый результат:** `DnsResult.IsSuccess == true`, список IP не пуст

**Test ID:** `PIPE-009`
**Что проверяет:** TCP Handshake (SYN → SYN-ACK)
**Для чего:** Проверка TCP-доступности
**Критерий успеха:** Соединение устанавливается с доступным хостом
**Входные данные:** `google.com:443`
**Ожидаемый результат:** `TcpResult.IsSuccess == true`

**Test ID:** `PIPE-010`
**Что проверяет:** TLS ClientHello → ServerHello
**Для чего:** Проверка DPI-блокировок на уровне TLS/SNI
**Критерий успеха:** ServerHello получен от доступного хоста
**Входные данные:** `google.com:443` с SNI
**Ожидаемый результат:** `TlsResult.IsSuccess == true`

**Test ID:** `PIPE-011`
**Что проверяет:** Reverse DNS (PTR) для IP
**Для чего:** Дополнительная информация для UI (техническое поле)
**Критерий успеха:** PTR-запрос выполняется (даже если результат пустой)
**Входные данные:** `8.8.8.8`
**Ожидаемый результат:** `rDnsResult` содержит hostname или null без exception

### 2.4 Classification
Legacy-классификатор удалён. Классификацию и формирование рекомендаций покрывает DPI2 слой (диагноз/план/маркеры),
поэтому PIPE-012..016 исключены из плана, чтобы strict-smoke не падал на «в плане есть, а в раннере нет».

### 2.5 Pipeline Health
**Test ID:** `PIPE-017`
**Что проверяет:** Периодический [PipelineHealth] лог
**Для чего:** Диагностика затыков/потерь данных в очередях
**Критерий успеха:** Лог выводится каждые N секунд с счётчиками этапов
**Входные данные:** Запущенный пайплайн
**Ожидаемый результат:** Строка вида `[PipelineHealth] enqueue:10 test:9 classify:9 ui:8`

**Test ID:** `PIPE-018`
**Что проверяет:** Auto-hostlist добавляется в intel-хвост (evidence/notes)
**Для чего:** Прокинуть auto-hostlist как источник контекста для Intel (сейчас: заметно в UI/QA; далее может участвовать в диагнозе)
**Критерий успеха:** В UI-строке с хвостом `[INTEL]` присутствует маркер `autoHL hits=... score=...`
**Входные данные:** Запущенный пайплайн с включённым `AutoHostlistService` и `InspectionSignalsSnapshot.HasSuspiciousRst=true`
**Ожидаемый результат:** Нота `autoHL` присутствует в intel-хвосте

**Test ID:** `PIPE-019`
**Что проверяет:** Auto-hostlist intel-only: без legacy типов (`BlockageSignals/GetSignals`)
**Для чего:** Зафиксировать, что auto-hostlist работает только на `InspectionSignalsSnapshot` и не требует legacy агрегата
**Критерий успеха:**
- Голый IP не добавляется в snapshot
- Домен добавляется на INTEL inspection signals
**Входные данные:** `HostTested` (с доменом и без домена) + `InspectionSignalsSnapshot.HasSuspiciousRst=true`
**Ожидаемый результат:** В snapshot появляется `example.com`, но не появляется `203.0.113.99`

---

## 3. Inspection Services (Глубокий анализ)

### 3.1 RST Inspection
**Test ID:** `INSP-001`
**Что проверяет:** Обнаружение RST Injection по TTL
**Для чего:** Отличить легитимный RST от инжектированного DPI
**Критерий успеха:** RST с аномальным TTL помечается как injection
**Входные данные:** RST-пакет с TTL=5 при обычном TTL=64
**Ожидаемый результат:** `RstInspectionService` логирует injection

**Test ID:** `INSP-002`
**Что проверяет:** Сравнение IP Identification
**Для чего:** Дополнительная эвристика для RST injection
**Критерий успеха:** Аномальный IP ID помечается как подозрительный
**Входные данные:** RST с IP ID сильно отличающимся от предыдущих пакетов
**Ожидаемый результат:** Warning в логе инспектора

### 3.2 UDP/QUIC Inspection
**Test ID:** `INSP-003`
**Что проверяет:** Обнаружение блокировки QUIC
**Для чего:** Провайдеры часто блокируют QUIC для форсирования HTTP/TLS
**Критерий успеха:** UDP-трафик на 443 с QUIC-сигнатурой детектируется
**Входные данные:** QUIC Initial packet на UDP:443
**Ожидаемый результат:** `UdpInspectionService` детектирует QUIC и проверяет доступность

### 3.3 Retransmission Tracking
**Test ID:** `INSP-004`
**Что проверяет:** Подсчёт TCP-ретрансмиссий
**Для чего:** Обнаружение Packet Drop (тихий дроп)
**Критерий успеха:** Высокий % ретрансмиссий (>10%) фиксируется
**Входные данные:** TCP-поток с 15% повторных отправок
**Ожидаемый результат:** `TcpRetransmissionTracker` логирует подозрение на Drop

### 3.4 HTTP Redirect Detection
**Test ID:** `INSP-005`
**Что проверяет:** Обнаружение редиректа на blockpage
**Для чего:** Определение метода блокировки через HTTP 301/302
**Критерий успеха:** Редирект на известную заглушку детектируется
**Входные данные:** HTTP 302 на `http://warning.rt.ru`
**Ожидаемый результат:** `HttpRedirectDetector` классифицирует как blockpage

---

## 4. Bypass Layer (Обход блокировок)

### 4.1 TlsBypassService
**Test ID:** `BYPASS-001`
**Что проверяет:** Регистрация BypassFilter в TrafficEngine
**Для чего:** Проверка, что обход включается корректно
**Критерий успеха:** Фильтр добавляется при `ApplyOptionsAsync`
**Входные данные:** Опции обхода с `TlsFragmentationEnabled = true`
**Ожидаемый результат:** `BypassFilter` присутствует в `TrafficEngine.ActiveFilters`

**Test ID:** `BYPASS-002`
**Что проверяет:** Удаление BypassFilter при отключении
**Для чего:** Проверка корректного cleanup
**Критерий успеха:** Фильтр удаляется при `DisableBypassAsync`
**Входные данные:** Активный обход
**Ожидаемый результат:** `BypassFilter` отсутствует в `TrafficEngine.ActiveFilters`

**Test ID:** `BYPASS-003`
**Что проверяет:** Сбор метрик фильтра (каждые 2 сек)
**Для чего:** Отслеживание работы обхода в UI
**Критерий успеха:** Событие `MetricsUpdated` публикуется периодически
**Входные данные:** Включённый bypass с TLS-трафиком
**Ожидаемый результат:** Метрики содержат `ClientHelloSeen`, `Fragmented`, `RstCount`

**Test ID:** `BYPASS-004`
**Что проверяет:** Вычисление вердикта (зелёный/жёлтый/красный)
**Для чего:** Индикация эффективности обхода
**Критерий успеха:** Правильная классификация по соотношению RST/фрагментаций
**Входные данные:** Метрики с ratio > 4 (красный), 1.5-4 (жёлтый), < 1.5 (зелёный)
**Ожидаемый результат:** Событие `VerdictChanged` с корректным цветом

**Test ID:** `BYPASS-005`
**Что проверяет:** Загрузка/сохранение пресетов из `bypass_profile.json`
**Для чего:** Персистентность настроек между запусками
**Критерий успеха:** Выбранный пресет и параметры восстанавливаются
**Входные данные:** Профиль с `PresetName = "Aggressive"`
**Ожидаемый результат:** `TlsBypassService` загружает параметры агрессивного пресета

### 4.2 BypassFilter
**Test ID:** `BYPASS-006`
**Что проверяет:** Фрагментация TLS ClientHello
**Для чего:** Базовая стратегия обхода DPI
**Критерий успеха:** ClientHello разбивается на 2+ TCP-сегмента
**Входные данные:** ClientHello длиной 300 байт, пресет `[80, 220]`
**Ожидаемый результат:** 2 TCP-сегмента с корректными seq/len, метрика `Fragmented++`

**Test ID:** `BYPASS-007`
**Что проверяет:** Disorder (обратный порядок сегментов)
**Для чего:** Усложнённая стратегия обхода
**Критерий успеха:** Сегменты отправляются в обратном порядке с корректными seq
**Входные данные:** ClientHello с опцией `TlsDisorderEnabled`
**Ожидаемый результат:** Сегменты идут в обратном порядке, данные валидны при реассемблинге

**Test ID:** `BYPASS-008`
**Что проверяет:** Fake TTL (фейковый пакет с коротким TTL)
**Для чего:** Обман DPI без доставки пакета до сервера
**Критерий успеха:** Фейковый пакет отправляется с TTL < реального
**Входные данные:** ClientHello с опцией `FakeTtlEnabled`, `FakeTtlValue = 5`
**Ожидаемый результат:** 2 пакета: fake (TTL=5) и real (TTL=64)

**Test ID:** `BYPASS-009`
**Что проверяет:** Drop RST (блокировка входящих RST)
**Для чего:** Игнорирование инжектированных reset-ов от DPI
**Критерий успеха:** RST-пакеты не доходят до приложения
**Входные данные:** Входящий RST-пакет с опцией `DropRstEnabled`
**Ожидаемый результат:** Метрика `RstDropped++`, RST не передаётся дальше

**Test ID:** `BYPASS-010`
**Что проверяет:** Фильтрация по порту 443 и наличию SNI
**Для чего:** Обрабатывать только релевантный TLS-трафик
**Критерий успеха:** Пакеты не на 443 или без SNI игнорируются
**Входные данные:** ClientHello на порт 80, ClientHello:443 без SNI
**Ожидаемый результат:** Метрики `Non443++`, `NoSni++`, фрагментация не выполняется

**Test ID:** `BYPASS-011`
**Что проверяет:** Порог длины ClientHello (threshold)
**Для чего:** Не фрагментировать короткие ClientHello
**Критерий успеха:** Пакеты < threshold не фрагментируются
**Входные данные:** ClientHello длиной 50 байт, threshold = 100
**Ожидаемый результат:** Метрика `ShortClientHello++`, пакет проходит без изменений

**Test ID:** `BYPASS-016`
**Что проверяет:** HTTP Host tricks (разрезание `Host:` по границе TCP сегментов)
**Для чего:** Техника обхода DPI для HTTP (TCP/80)
**Критерий успеха:** `Host:` разделён на 2 сегмента, оригинальный пакет отброшен
**Входные данные:** HTTP запрос `GET ...\r\nHost: example.com\r\n...`
**Ожидаемый результат:** 2 TCP сегмента с корректным SEQ/len, payload реассемблируется обратно без потерь

**Test ID:** `BYPASS-017`
**Что проверяет:** BadChecksum для fake-пакета (портит TCP checksum)
**Для чего:** Техника обхода DPI/фильтрации по сигнатурам (MVP на fake пакете)
**Критерий успеха:** Fake пакет отправляется через `SendEx` без пересчёта checksum и со сбросом checksum-флагов addr
**Входные данные:** TLS ClientHello:443 (fake стратегия)
**Ожидаемый результат:** В отправленном fake пакете TCP checksum испорчен (детерминированно), `SendEx` использован

### 4.3 TTL Trick & Auto-adjust
**Test ID:** `BYPASS-012`
**Что проверяет:** Ручное включение TTL Trick
**Для чего:** Пользовательская настройка TTL для обхода
**Критерий успеха:** TTL применяется к исходящим пакетам
**Входные данные:** `TtlTrickEnabled = true`, `TtlTrickValue = 10`
**Ожидаемый результат:** Исходящие пакеты имеют TTL = 10

**Test ID:** `BYPASS-013`
**Что проверяет:** Автоподбор TTL (`AutoTtlEnabled`)
**Для чего:** Автоматическое нахождение оптимального TTL
**Критерий успеха:** Сервис перебирает значения и выбирает лучшее
**Входные данные:** `AutoTtlEnabled = true`, набор {5, 10, 15, 20}
**Ожидаемый результат:** Лучший TTL сохраняется в `bypass_profile.json`

**Test ID:** `BYPASS-014`
**Что проверяет:** Автокоррекция минимального чанка (Aggressive)
**Для чего:** Адаптация к DPI при всплеске RST
**Критерий успеха:** Минимальный чанк ужимается до 4 при раннем всплеске
**Входные данные:** Пресет Aggressive, много RST в первые секунды
**Ожидаемый результат:** `MinChunkSize` уменьшается, опции переприменяются

**Test ID:** `BYPASS-015`
**Что проверяет:** Релаксация чанка при стабильном зелёном (>30s)
**Для чего:** Постепенное снижение агрессивности при успехе
**Критерий успеха:** Минимальный чанк слегка уменьшается (не ниже 4)
**Входные данные:** Стабильный зелёный статус >30 секунд
**Ожидаемый результат:** `MinChunkSize` немного уменьшается, опции переприменяются

---

## 5. DPI Intelligence (INTEL)

### 5.1 Signals Collection
**Test ID:** `DPI2-001`
**Что проверяет:** Адаптация legacy сигналов в SignalsAdapter
**Для чего:** Преобразование legacy `BlockageSignals` в INTEL-формат
**Критерий успеха:** События добавляются в TTL-store
**Входные данные:** `BlockageSignals` с `BlockageType = TCP_RESET`
**Ожидаемый результат:** `SignalsAdapter.Observe()` создаёт `SignalEvent` и добавляет в store

**Test ID:** `DPI2-002`
**Что проверяет:** TTL событий (10 минут)
**Для чего:** Очистка старых событий из памяти
**Критерий успеха:** События старше 10 минут удаляются
**Входные данные:** События с timestamp > 10 минут назад
**Ожидаемый результат:** `TTLBlockageStateStore.Append()` удаляет старые события

**Test ID:** `DPI2-003`
**Что проверяет:** Агрегация событий по окну (30s default, 60s extended)
**Для чего:** Построение среза `BlockageSignals` для диагностики
**Критерий успеха:** Агрегированные признаки считаются корректно
**Входные данные:** 10 событий за 25 секунд (timeout/rst/retx)
**Ожидаемый результат:** `BuildAggregatedSignals()` возвращает срез с правильными счётчиками

**Test ID:** `DPI2-016`
**Что проверяет:** Извлечение `RstTtlDelta` и `RstLatency` в `BuildSnapshot`
**Для чего:** Устойчивые улики для `ActiveDpiEdge/StatefulDpi` (RST TTL delta/latency)
**Критерий успеха:** `RstTtlDelta` вычисляется из строки инспектора, `RstLatency` берётся из TCP latency
**Входные данные:** `TCP_CONNECTION_RESET` + `HasSuspiciousRst=true` + `SuspiciousRstDetails="TTL=64 (обычный=50-55)"` + `TcpLatencyMs=120`
**Ожидаемый результат:** `RstTtlDelta=9`, `RstLatency≈120ms`

### 5.2 Diagnosis Engine
**Test ID:** `DPI2-004`
**Что проверяет:** Постановка диагноза по `BlockageSignals`
**Для чего:** Определение типа блокировки и уверенности
**Критерий успеха:** Диагноз с `confidence >= 50` формируется
**Входные данные:** `BlockageSignals` с высоким retx-rate и timeout
**Ожидаемый результат:** `StandardDiagnosisEngine.Diagnose()` возвращает `DiagnosisId.SilentDrop`, `confidence > 50`

**Test ID:** `DPI2-005`
**Что проверяет:** Формирование пояснения (без упоминания стратегий)
**Для чего:** Пользователю понятно "что не так" без технического жаргона
**Критерий успеха:** Пояснение содержит факты (timeout, retx), но не стратегии
**Входные данные:** Диагноз `DPI_FILTER` (DPI фильтрация)
**Ожидаемый результат:** Explanation вида "TLS ClientHello не доходит, высокий timeout на 443"

**Test ID:** `DPI2-006`
**Что проверяет:** Gate 1→2 маркеры в логе `[INTEL][GATE1]`
**Для чего:** Проверка корректности перехода от сбора к диагностике
**Критерий успеха:** Маркеры появляются в UI-логе при каждом переходе
**Входные данные:** Успешное построение `BlockageSignals`
**Ожидаемый результат:** Строка `[INTEL][GATE1] hostKey=example.com recentCount=5 timeline=...`

**Test ID:** `DPI2-017`
**Что проверяет:** `RST TTL delta + fast` классифицируется как `ActiveDpiEdge`
**Для чего:** Уменьшить долю `Unknown` при RST-инъекциях
**Критерий успеха:** Диагноз `ActiveDpiEdge` и `confidence >= 60`
**Входные данные:** `HasTcpReset=true`, `RstTtlDelta=10`, `RstLatency=120ms`, `SuspiciousRstCount>=2`
**Ожидаемый результат:** `DiagnosisId.ActiveDpiEdge`

**Test ID:** `DPI2-018`
**Что проверяет:** `RST TTL delta + slow` классифицируется как `StatefulDpi`
**Для чего:** Разделять активную инъекцию и stateful инспекцию
**Критерий успеха:** Диагноз `StatefulDpi` и `confidence >= 60`
**Входные данные:** `HasTcpReset=true`, `RstTtlDelta=10`, `RstLatency=900ms`, `SuspiciousRstCount>=2`
**Ожидаемый результат:** `DiagnosisId.StatefulDpi`

**Test ID:** `DPI2-031`
**Что проверяет:** `BuildSnapshot` извлекает `RstIpIdDelta` и считает `SuspiciousRstCount`
**Для чего:** Поддержать альтернативную улику RST-инжекции (IPID) и «устойчивость» улик
**Критерий успеха:** `RstIpIdDelta` вычисляется из строки инспектора, `SuspiciousRstCount` равен числу событий в окне
**Входные данные:** 2 события `SuspiciousRstObserved` с `Value="IPID=110 (expected 100-120, last 105)"`
**Ожидаемый результат:** `RstIpIdDelta=5`, `SuspiciousRstCount=2`

**Test ID:** `DPI2-032`
**Что проверяет:** Single anomaly по RST не выдаёт DPI-id
**Для чего:** Снизить ложную уверенность на «рабочих» целях при единичных событиях
**Критерий успеха:** Возвращается `DiagnosisId.Unknown` (без `ActiveDpiEdge/StatefulDpi`)
**Входные данные:** `HasTcpReset=true`, `RstTtlDelta=10`, `RstLatency=120ms`, `SuspiciousRstCount=1`
**Ожидаемый результат:** `DiagnosisId.Unknown`, `confidence=55`, `rule=tcp-rst+single-anomaly`

### 5.3 Strategy Selector
**Test ID:** `DPI2-007`
**Что проверяет:** Построение `BypassPlan` по `DiagnosisResult`
**Для чего:** Рекомендации пользователю по обходу
**Критерий успеха:** План содержит стратегии для диагноза
**Входные данные:** `DiagnosisResult` + `BypassPlan`
**Ожидаемый результат:** Строка вида `[INTEL] example.com: DPI_FILTER (80%) - TLS фильтрация, рекомендуется: Fragment+Disorder`

**Test ID:** `DPI2-008`
**Что проверяет:** Блокировка `RiskLevel.High` при `confidence < 70`
**Для чего:** Не применять агрессивные стратегии при низкой уверенности
**Критерий успеха:** High-risk стратегии отсутствуют в плане
**Входные данные:** `DiagnosisResult` с `confidence = 60`
**Ожидаемый результат:** План не содержит стратегий с `RiskLevel.High`

**Test ID:** `DPI2-009`
**Что проверяет:** Пустой план при `confidence < 50`
**Для чего:** Не давать рекомендаций при слишком низкой уверенности
**Критерий успеха:** План пустой или содержит только `NONE`
**Входные данные:** `DiagnosisResult` с `confidence = 40`
**Ожидаемый результат:** `BypassPlan.Strategies.IsEmpty == true`

**Test ID:** `DPI2-010`
**Что проверяет:** Warning при нереализованных стратегиях
**Для чего:** Не ломать пайплайн на будущих стратегиях
**Критерий успеха:** Предупреждение в лог, стратегия пропускается
**Входные данные:** `DiagnosisResult`, при котором селектор сформирует кандидата с нереализованной `StrategyId`
**Ожидаемый результат:** Warning в логе, стратегия не включена

**Test ID:** `DPI2-033`
**Что проверяет:** Заполнение `BypassPlan.DeferredStrategies` для DPI-диагнозов
**Для чего:** Показывать «возможные будущие техники» без применения и без влияния на текущий план
**Критерий успеха:** `DeferredStrategies` содержит `HttpHostTricks`, `QuicObfuscation`, `BadChecksum`, но эти стратегии отсутствуют в `Strategies`
**Входные данные:** `DiagnosisResult` с `DiagnosisId.ActiveDpiEdge` или `DiagnosisId.StatefulDpi` и `confidence >= 70`
**Ожидаемый результат:** В `Reasoning` присутствует суффикс `deferred: ...`

**Test ID:** `DPI2-034`
**Что проверяет:** `DnsHijack` маппится в low-risk стратегию `UseDoh`
**Для чего:** Единое и предсказуемое поведение INTEL при «чисто DNS» проблемах
**Критерий успеха:** План содержит ровно одну стратегию `UseDoh` и не включает TLS-обход/assist-флаги
**Входные данные:** `DiagnosisResult(DnsHijack, confidence >= 50)`
**Ожидаемый результат:** `plan.Strategies=[UseDoh]`, `DropUdp443=false`, `AllowNoSni=false`

### 5.4 Executor MVP
**Test ID:** `DPI2-011`
**Что проверяет:** Форматирование вывода для UI (1-2 строки)
**Для чего:** Компактный вывод рекомендаций без спама
**Критерий успеха:** Вывод содержит диагноз + уверенность + короткое объяснение
**Входные данные:** `DiagnosisResult`
**Ожидаемый результат:** Строки не содержат переводы строк, присутствует префикс `[INTEL]`

**Test ID:** `DPI2-012`
**Что проверяет:** Префикс `[INTEL]` во всех выводах
**Для чего:** Отличить рекомендации INTEL от legacy
**Критерий успеха:** Все строки рекомендаций INTEL начинаются с `[INTEL]`
**Входные данные:** Любой INTEL-вывод
**Ожидаемый результат:** Префикс `[INTEL]` присутствует

**Test ID:** `DPI2-013`
**Что проверяет:** Отсутствие auto-apply в MVP
**Для чего:** Применение обхода только вручную пользователем
**Критерий успеха:** Executor не вызывает `TrafficEngine` или `BypassController`
**Входные данные:** Любой `BypassPlan`
**Ожидаемый результат:** Только логирование, никаких вызовов bypass-методов

**Test ID:** `DPI2-025`
**Что проверяет:** Guard: в intel runtime-пути нет legacy `GetSignals(...)`/`BlockageSignals`
**Для чего:** Не допустить незаметного возврата legacy источника фактов в INTEL-цепочку
**Критерий успеха:** В `Core/Intelligence/*` и ключевых runtime-файлах нет вызовов `GetSignals(...)` и упоминаний `BlockageSignals`
**Входные данные:** Чтение исходников (grep/regex по набору файлов)
**Ожидаемый результат:** Тест PASS, список нарушителей пуст

**Test ID:** `DPI2-026`
**Что проверяет:** Guard: `TrafficEngine`/`TlsBypassService` нельзя вызывать вне `BypassStateManager`
**Для чего:** Закрепить single source of truth и ловить попытки управлять движком/обходом «мимо менеджера»
**Критерий успеха:** В strict guard-режиме прямые вызовы приводят к исключению, а вызовы через менеджер — проходят
**Входные данные:** Созданный `BypassStateManager` + попытки прямого вызова API
**Ожидаемый результат:** Direct calls → exception; Manager calls → PASS

**Test ID:** `DPI2-027`
**Что проверяет:** Watchdog: crash recovery + watchdog timeout выключают bypass
**Для чего:** Fail-safe: после некорректного завершения/зависания метрик обход не должен оставаться активным
**Критерий успеха:**
- При наличии `WasBypassActive=true` и `CleanShutdown=false` в журнале сессии выполняется принудительный `Disable`.
- При активном bypass и отсутствии heartbeat/метрик дольше окна — выполняется авто-`Disable`.
**Входные данные:** Временный файл журнала сессии (`ISP_AUDIT_BYPASS_SESSION_PATH`) + ускоренные таймауты watchdog
**Ожидаемый результат:** `WasBypassActive` становится `false`, а опции bypass отключаются автоматически

**Test ID:** `DPI2-028`
**Что проверяет:** Activation Detection: статусы `ENGINE_DEAD / NOT_ACTIVATED / ACTIVATED / NO_TRAFFIC / UNKNOWN`
**Для чего:** Детально различать «движок не жив», «нет трафика», «обход не активировался», «обход активирован»
**Критерий успеха:** Для синтетических метрик/таймстампов детектор возвращает ожидаемый статус детерминированно
**Входные данные:** Синтетические `TlsBypassMetrics` (smoke-инъекция в менеджер) + управляемые таймауты через env
**Ожидаемый результат:** Статусы соответствуют таблице, тест PASS

**Test ID:** `DPI2-029`
**Что проверяет:** Outcome Check (HTTPS): `SUCCESS / FAILED / UNKNOWN` через tagged probe
**Для чего:** Честно сообщать исход для HTTPS без ложных выводов из пассивного анализа (без MITM)
**Критерий успеха:**
- Без цели (`host`) outcome остаётся `UNKNOWN`.
- При заданной цели outcome может стать `SUCCESS/FAILED` только на основании активного probe.
**Входные данные:** `BypassStateManager` + smoke-подмена probe (детерминированная) + `ISP_AUDIT_OUTCOME_DELAY_MS=0`
**Ожидаемый результат:** Тест PASS, статусы детерминированны

**Test ID:** `DPI2-030`
**Что проверяет:** QUIC fallback (DROP UDP/443) селективен по observed IP цели
**Для чего:** Уменьшить побочные эффекты глобального глушения UDP/443 (QUIC)
**Критерий успеха:**
- UDP/443 к целевому IP дропается.
- UDP/443 к нецелевому IP пропускается.
**Входные данные:** `BypassFilter` + синтетические IPv4 UDP пакеты на порт 443 + заданный target IP список
**Ожидаемый результат:** Тест PASS, `Udp443Dropped` увеличивается только для пакета к цели

### 5.4.1 Policy-Driven Execution Plane (Stage 0)
**Test ID:** `DPI2-040`
**Что проверяет:** `PolicySetCompiler` детектирует hard-конфликты политик
**Для чего:** Не допустить неоднозначного выбора действия на execution plane (один пакет → одно решение)
**Критерий успеха:**
- При пересечении `MatchCondition` и одинаковом `Priority`, но разных `PolicyAction` компиляция падает с описанием конфликтов.
- При разных `Priority` (или disjoint match) компиляция проходит.
**Входные данные:** Синтетический набор `FlowPolicy` с пересечением match и одинаковым priority
**Ожидаемый результат:** Тест PASS, hard-conflicts детектируются детерминированно

### 5.4.2 Policy-Driven Execution Plane (Stage 1)
**Test ID:** `DPI2-041`
**Что проверяет:** Policy-driven runtime для UDP/443 использует `DecisionGraphSnapshot` и даёт per-policy наблюдаемость
**Для чего:** Перевести QUIC fallback (DROP UDP/443) на execution plane и получить детерминированное решение + минимальные метрики
**Критерий успеха:**
- UDP/443 к целевому IP дропается.
- UDP/443 к нецелевому IP пропускается.
- Per-policy счётчик (по policy-id) увеличивается на 1 для применённой политики.
**Входные данные:** `BypassFilter` + синтетические IPv4 UDP пакеты на порт 443 + snapshot с `PolicyAction.DropUdp443` + `ISP_AUDIT_POLICY_DRIVEN_UDP443=1`
**Ожидаемый результат:** Тест PASS

### 5.4.3 Policy-Driven Execution Plane (Stage 2)
**Test ID:** `DPI2-042`
**Что проверяет:** TTL endpoint block (reconnect‑nudge) работает как TTL‑политика и истекает по TTL
**Для чего:** Перевести временную блокировку endpoint-ов на policy-driven модель с самым высоким приоритетом и детерминированным истечением
**Критерий успеха:**
- До истечения TTL: трафик к целевому IP:443 дропается.
- До истечения TTL: трафик к нецелевому IP:443 не дропается.
- После истечения TTL: трафик к целевому IP:443 перестаёт дропаться.
**Входные данные:** `TemporaryEndpointBlockFilter` + синтетические IPv4 TCP пакеты на порт 443 + `ISP_AUDIT_POLICY_DRIVEN_TTLBLOCK=1`
**Ожидаемый результат:** Тест PASS

### 5.4.4 Policy-Driven Execution Plane (Stage 3)
**Test ID:** `DPI2-043`
**Что проверяет:** TCP/80 HTTP Host tricks управляются политикой через `DecisionGraphSnapshot`
**Для чего:** Перевести HTTP Host tricks (разрез Host заголовка) на policy-driven модель без регрессий
**Критерий успеха:**
- При включённом gate и наличии политики: оригинальный пакет дропается, отправляются 2 сегмента.
- Per-policy счётчик (по policy-id) увеличивается на 1.
**Входные данные:** `BypassFilter` + синтетические IPv4 TCP пакеты на порт 80 с HTTP `Host:` + snapshot с `PolicyAction.HttpHostTricks` + `ISP_AUDIT_POLICY_DRIVEN_TCP80=1`
**Ожидаемый результат:** Тест PASS

### 5.4.5 Policy-Driven Execution Plane (Stage 4)
**Test ID:** `DPI2-044`
**Что проверяет:** TCP/443 TLS ClientHello выбирает стратегию через `DecisionGraphSnapshot` (per-endpoint) с fallback на legacy
**Для чего:** Перейти от «одной глобальной TLS стратегии» к policy-выбору стратегии как функции от пакета (dst_ip/proto/port/tls_stage)
**Критерий успеха:**
- Для IP A: применяется policy-стратегия `Fragment` (2 отправки сегментов) и оригинальный пакет дропается.
- Для IP B: применяется policy-стратегия `FakeDisorder` (1 fake + 2 сегмента = 3 отправки) и оригинальный пакет дропается.
- Для IP C без мэтча: применяется legacy стратегия из профиля (`Fake`, 1 отправка) — fallback корректен.
- Per-policy счётчики (по policy-id) увеличиваются на 1 для A и B.
**Входные данные:** `BypassFilter` + синтетические IPv4 TCP пакеты на порт 443 с TLS ClientHello (минимальная сигнатура) + snapshot с `PolicyAction.TlsBypassStrategy(...)` + `ISP_AUDIT_POLICY_DRIVEN_TCP443=1`
**Ожидаемый результат:** Тест PASS

### 5.4.6 Policy-Driven Execution Plane (Stage 5)
**Test ID:** `DPI2-045`
**Что проверяет:** Semantic Groups: статус группы (NO_TRAFFIC / PARTIAL / ENABLED) вычисляется детерминированно по policy-matched метрикам
**Для чего:** Ввести наблюдаемое состояние «группа = пакет политик» и не путать отсутствие трафика с частичным покрытием
**Критерий успеха:**
**Входные данные:** `BypassFilter` + `DecisionGraphSnapshot` с 3 policy-id (TCP/443 ClientHello) + синтетический трафик к 2/3/3 endpoint-ам + `ISP_AUDIT_POLICY_DRIVEN_TCP443=1`
**Ожидаемый результат:** Тест PASS

### 5.4.7 Policy-Driven Execution Plane (Stage 6)
**Test ID:** `DPI2-046`
**Что проверяет:** Экспорт policy snapshot (`PolicySnapshotJson`) и таблица `ActivePolicies` детерминированны и не пустые при активном decision graph
**Для чего:** Зафиксировать наблюдаемость policy-driven execution (экспорт JSON для репорта и UI-таблица политик)
**Критерий успеха:**
- `PolicySnapshotJson` не пустой и парсится как JSON (Version=v1)
- JSON содержит policy-id теста и `AppliedCount > 0`
- `ActivePolicies` содержит ту же policy-id и `AppliedCount > 0`
**Входные данные:** `TlsBypassService` (smoke-seam `PullMetricsOnceAsyncForSmoke`) + `BypassFilter` + snapshot с `PolicyAction.DropUdp443` + синтетический UDP/443 трафик + `ISP_AUDIT_POLICY_DRIVEN_UDP443=1`
**Ожидаемый результат:** Тест PASS

### 5.4.8 Policy-Driven Execution Plane (Hardening)
**Test ID:** `DPI2-047`
**Что проверяет:** Per-target TLS политики (DstIpv4Set) собираются из candidate endpoints (seed) без зависимости от DNS resolve
**Для чего:** Практически снизить «хаос по целям»: per-target политики должны собираться сразу после apply, даже если DNS ломается/фильтруется
**Критерий успеха:** В `PolicySnapshotJson` присутствует per-target `tcp443_tls_*` политика с `DstIpv4SetPreview`, содержащим IP из candidate endpoints
**Входные данные:** `BypassStateManager` + `ActiveTargetPolicy` + `UpdateActiveTargetCandidateEndpointsBestEffort(...)` + `ISP_AUDIT_POLICY_DRIVEN_TCP443=1`
**Ожидаемый результат:** Тест PASS

**Test ID:** `DPI2-048`
**Что проверяет:** Per-target TCP/80 HostTricks политики (DstIpv4Set) собираются из candidate endpoints (seed) без зависимости от DNS resolve
**Для чего:** Закрыть «хаос по целям» и для TCP/80: если есть активные цели, blast-radius должен быть per-target, даже когда DNS resolve недоступен
**Критерий успеха:** В `PolicySnapshotJson` присутствует per-target `tcp80_http_host_tricks_*` политика с `DstIpv4SetPreview`, содержащим IP из candidate endpoints
**Входные данные:** `BypassStateManager` + `ActiveTargetPolicy(HttpHostTricksEnabled=true)` + `UpdateActiveTargetCandidateEndpointsBestEffort(...)` + `ISP_AUDIT_POLICY_DRIVEN_TCP80=1`
**Ожидаемый результат:** Тест PASS
**Test ID:** `DPI2-014`
**Что проверяет:** Ранжирование стратегий по feedback поверх basePriority
**Для чего:** Улучшать порядок рекомендаций на основе успешности
**Критерий успеха:** При достаточной выборке успешная стратегия поднимается выше
**Входные данные:** Feedback (ActiveDpiEdge + TlsFragment=Success, ActiveDpiEdge + TlsDisorder=Failure)
**Ожидаемый результат:** Первой в плане становится `TlsFragment` (при стабильном успехе)

**Test ID:** `DPI2-015`
**Что проверяет:** Feedback не влияет при малой выборке
**Для чего:** Не реагировать на шум/случайные единичные исходы
**Критерий успеха:** При total < MinSamples порядок остаётся как по basePriority
**Входные данные:** Feedback с 4 событиями успеха
**Ожидаемый результат:** Первой остаётся `TlsDisorder` (basePriority=90)

### 5.6 Executor (Manual Apply)
**Test ID:** `DPI2-019`
**Что проверяет:** Ручное применение `BypassPlan` корректно маппит стратегии в bypass-опции
**Для чего:** Гарантировать, что план действительно приводит к нужным настройкам (без auto-apply)
**Критерий успеха:** После применения включены ожидаемые флаги (например, `TLS_FRAGMENT`, `DROP_RST`)
**Входные данные:** `BypassPlan` с `TlsFragment` + `DropRst`
**Ожидаемый результат:** `BypassController` отражает включённые опции

**Test ID:** `DPI2-020`
**Что проверяет:** Отмена/таймаут применения приводит к безопасному откату (rollback)
**Для чего:** Не оставлять систему в частично применённом состоянии при Cancel/Timeout
**Критерий успеха:** Состояние после отмены совпадает со snapshot до применения
**Входные данные:** Включённая исходная опция + `CancellationToken` с быстрым Cancel
**Ожидаемый результат:** Выбрасывается `OperationCanceledException`, опции откатываются

**Test ID:** `DPI2-021`
**Что проверяет:** Pipeline не делает auto-apply (только строит/публикует план)
**Для чего:** Применение обхода должно быть строго по клику пользователя
**Критерий успеха:** В IL `LiveTestingPipeline` нет вызовов к `BypassController`/`TlsBypassService`
**Входные данные:** Рефлексия/IL-анализ `LiveTestingPipeline`
**Ожидаемый результат:** Запрещённых вызовов не обнаружено

**Test ID:** `DPI2-022`
**Что проверяет:** Параметры `TlsFragment` из `BypassPlan` реально влияют на выбранный пресет и `AutoAdjustAggressive`
**Для чего:** Executor должен применять то, что описано в плане (детерминизм), а не текущее UI-состояние
**Критерий успеха:** После применения выбран пресет по sizes и включён `AutoAdjustAggressive=true`
**Входные данные:** `BypassPlan` с `TlsFragment.Parameters: { TlsFragmentSizes=[32,32], AutoAdjustAggressive=true }`
**Ожидаемый результат:** `SelectedFragmentPreset.Sizes == [32,32]`, `IsAutoAdjustAggressive == true`

**Test ID:** `DPI2-023`
**Что проверяет:** Селектор кладёт параметры `TlsFragment` (PresetName/TlsFragmentSizes) прямо в `BypassPlan`
**Для чего:** Детерминизм: executor не должен зависеть от текущего пресета пользователя
**Критерий успеха:** В плане у `TlsFragment` присутствуют `PresetName` и `TlsFragmentSizes`
**Входные данные:** `DiagnosisResult(SilentDrop, confidence=80)`
**Ожидаемый результат:** `plan.Strategies[].Parameters` содержит `PresetName="Стандарт"` и `TlsFragmentSizes=[64]`

**Test ID:** `DPI2-024`
**Что проверяет:** E2E цепочку `selector → plan → ApplyIntelPlanAsync` (параметры из плана реально применяются)
**Для чего:** Самый важный функциональный контракт: рекомендации должны быть исполнимы и детерминированы
**Критерий успеха:** После apply включены ожидаемые флаги и выбран ожидаемый пресет/размеры из параметров плана
**Входные данные:** `DiagnosisResult(SilentDrop, confidence=80)` → `StandardStrategySelector.Select(...)`
**Ожидаемый результат:** `IsFragmentEnabled=true`, `IsDropRstEnabled=true`, `SelectedFragmentPreset.Name=="Стандарт"`, sizes `[64]`, `AutoAdjustAggressive=false`

---

## 6. UI Layer (WPF)

### 6.1 MainViewModel
**Test ID:** `UI-001`
**Что проверяет:** Инициализация DiagnosticOrchestrator
**Для чего:** Проверка создания всех зависимостей
**Критерий успеха:** Orchestrator создаётся без исключений
**Входные данные:** ViewModel при старте
**Ожидаемый результат:** `orchestrator != null`, сервисы инициализированы

**Test ID:** `UI-002`
**Что проверяет:** Обработка команды Start/Stop
**Для чего:** Проверка запуска/остановки диагностики
**Критерий успеха:** Pipeline запускается/останавливается
**Входные данные:** Клик на кнопку "Старт"
**Ожидаемый результат:** `orchestrator.StartAsync()` вызывается, UI обновляется

**Test ID:** `UI-003`
**Что проверяет:** Обработка ошибок (async void)
**Для чего:** Проверка, что исключения не проглатываются
**Критерий успеха:** Ошибка отображается в UI
**Входные данные:** Исключение в async void методе
**Ожидаемый результат:** MessageBox или лог с ошибкой

### 6.2 BypassController
**Test ID:** `UI-004`
**Что проверяет:** Биндинг UI-тумблеров к TlsBypassService
**Для чего:** Синхронизация состояния UI с сервисом
**Критерий успеха:** Изменение тумблера вызывает метод сервиса
**Входные данные:** Включение "Fragment" в UI
**Ожидаемый результат:** `TlsBypassService.ApplyOptionsAsync()` вызывается с `TlsFragmentationEnabled = true`

**Test ID:** `UI-005`
**Что проверяет:** Загрузка/сохранение пресета в `bypass_profile.json`
**Для чего:** Персистентность настроек
**Критерий успеха:** Выбранный пресет восстанавливается при запуске
**Входные данные:** Профиль с выбранным пресетом
**Ожидаемый результат:** `BypassController` восстанавливает пресет без перезаписи TTL/redirect rules

**Test ID:** `UI-006`
**Что проверяет:** Отображение метрик bypass (план фрагментации, timestamp)
**Для чего:** Визуализация работы обхода
**Критерий успеха:** Метрики обновляются из событий `TlsBypassService`
**Входные данные:** Событие `MetricsUpdated`
**Ожидаемый результат:** UI показывает план фрагментации, активный пресет, минимальный чанк

**Test ID:** `UI-007`
**Что проверяет:** Подсветка карточки по вердикту (зелёный/жёлтый/красный)
**Для чего:** Визуальная индикация эффективности
**Критерий успеха:** Карточка меняет цвет в зависимости от статуса
**Входные данные:** Событие `VerdictChanged` с красным статусом
**Ожидаемый результат:** Карточка подсвечивается красным, серые статусы не подсвечиваются

### 6.3 TestResultsManager
**Test ID:** `UI-008`
**Что проверяет:** Добавление результата в ObservableCollection
**Для чего:** Отображение новой карточки в UI
**Критерий успеха:** Карточка появляется в списке
**Входные данные:** `TestResult` с проблемой
**Ожидаемый результат:** `ObservableCollection` содержит новый элемент

**Test ID:** `UI-009`
**Что проверяет:** Обновление существующей карточки
**Для чего:** Избежать дублирования карточек для одного хоста
**Критерий успеха:** Существующая карточка обновляется
**Входные данные:** Повторный `TestResult` для того же хоста
**Ожидаемый результат:** Количество карточек не увеличивается, данные обновлены

**Test ID:** `UI-010`
**Что проверяет:** Парсинг строк пайплайна (`ParsePipelineMessage`)
**Для чего:** Преобразование лог-строк в UI-модели
**Критерий успеха:** Строки корректно парсятся
**Входные данные:** Строки вида `[Classification] host=example.com type=TCP_RESET`
**Ожидаемый результат:** `TestResult` с корректными полями

**Test ID:** `UI-011`
**Что проверяет:** UI-Reducer smoke-режим (`--ui-reducer-smoke`)
**Для чего:** Воспроизводимая проверка детерминизма UI без GUI
**Критерий успеха:** Типовые строки обрабатываются без исключений
**Входные данные:** Набор типовых лог-строк пайплайна
**Ожидаемый результат:** Все строки парсятся, результаты логируются

**Test ID:** `UI-012`
**Что проверяет:** Приоритет SNI/hostname над IP в ключе карточки
**Для чего:** Человеко-понятное отображение
**Критерий успеха:** Ключ карточки использует hostname, если известен
**Входные данные:** Событие с IP и hostname
**Ожидаемый результат:** Карточка отображает `example.com`, а не `93.184.216.34`

**Test ID:** `UI-013`
**Что проверяет:** P0.6 — UX уведомления о смене сети (без GUI)
**Для чего:** Гарантия, что ViewModel умеет показать/скрыть уведомление и команды подключены
**Критерий успеха:** Уведомление показывается и скрывается командой «Игнорировать»
**Входные данные:** Принудительный вызов `ShowNetworkChangePrompt` через smoke/reflection
**Ожидаемый результат:** `IsNetworkChangePromptVisible=true`, затем `false` после `NetworkIgnoreCommand`

---

## 7. Orchestration & Process Tracking

### 7.1 DiagnosticOrchestrator
**Test ID:** `ORCH-001`
**Что проверяет:** Запуск/остановка LiveTestingPipeline
**Для чего:** Управление жизненным циклом пайплайна
**Критерий успеха:** Pipeline запускается/останавливается корректно
**Входные данные:** `StartAsync()` / `StopAsync()`
**Ожидаемый результат:** Pipeline в соответствующем состоянии

**Test ID:** `ORCH-002`
**Что проверяет:** Управление фоновыми сервисами (TrafficEngine, ConnectionMonitor)
**Для чего:** Инициализация/cleanup сервисов
**Критерий успеха:** Сервисы запускаются/останавливаются вместе с orchestrator
**Входные данные:** Старт orchestrator
**Ожидаемый результат:** `TrafficEngine.Initialize()` и `ConnectionMonitor.Start()` вызываются

**Test ID:** `ORCH-003`
**Что проверяет:** Гейтирование SNI по PID
**Для чего:** Фильтрация SNI для целевого процесса
**Критерий успеха:** Только SNI от целевого процесса попадают в пайплайн
**Входные данные:** SNI-события от разных процессов, фильтр по одному PID
**Ожидаемый результат:** Только SNI с remote endpoint, принадлежащим целевому PID, проходят дальше

**Test ID:** `ORCH-004`
**Что проверяет:** Буфер ранних SNI для Steam/attach сценариев
**Для чего:** Не терять SNI, пришедший до появления PID
**Критерий успеха:** SNI сохраняется в буфере на несколько секунд
**Входные данные:** SNI до события соединения с PID
**Ожидаемый результат:** SNI проходит в пайплайн после появления соответствующего PID

**Test ID:** `ORCH-005`
**Что проверяет:** Отслеживание целевых процессов (PidTrackerService)
**Для чего:** Мониторинг жизненного цикла целевого процесса
**Критерий успеха:** Orchestrator реагирует на завершение процесса
**Входные данные:** Целевой процесс завершается
**Ожидаемый результат:** Orchestrator логирует событие или останавливает мониторинг

### 7.2 PidTrackerService
**Test ID:** `ORCH-006`
**Что проверяет:** Добавление/удаление PID из отслеживаемых
**Для чего:** Динамическое управление списком целевых процессов
**Критерий успеха:** PID добавляется/удаляется корректно
**Входные данные:** `AddPid(1234)` / `RemovePid(1234)`
**Ожидаемый результат:** `TrackedPids` содержит/не содержит PID

**Test ID:** `ORCH-007`
**Что проверяет:** Проверка принадлежности PID к отслеживаемым
**Для чего:** Быстрая фильтрация событий
**Критерий успеха:** Метод `IsPidTracked()` возвращает правильный результат
**Входные данные:** PID в списке и вне списка
**Ожидаемый результат:** `true` для отслеживаемого, `false` для остальных

---

## 8. Configuration & Persistence

### 8.1 Config (Global State)
**Test ID:** `CFG-001`
**Что проверяет:** Загрузка `bypass_profile.json`
**Для чего:** Восстановление настроек обхода
**Критерий успеха:** Профиль загружается без ошибок
**Входные данные:** Валидный JSON-файл
**Ожидаемый результат:** `Config.ActiveProfile` содержит данные из файла

**Test ID:** `CFG-002`
**Что проверяет:** Сохранение изменений в профиль
**Для чего:** Персистентность настроек между запусками
**Критерий успеха:** Изменения записываются в файл
**Входные данные:** Изменённый пресет
**Ожидаемый результат:** JSON-файл обновлён, новые значения присутствуют

**Test ID:** `CFG-003`
**Что проверяет:** Обработка некорректного JSON
**Для чего:** Graceful degradation при повреждённом файле
**Критерий успеха:** Приложение не крашится, используется дефолтный профиль
**Входные данные:** Повреждённый JSON
**Ожидаемый результат:** Warning в логе, дефолтные настройки применены

### 8.2 NoiseHostFilter
**Test ID:** `CFG-004`
**Что проверяет:** Singleton-паттерн (`NoiseHostFilter.Instance`)
**Для чего:** Единая точка доступа к фильтру
**Критерий успеха:** Один экземпляр на всё приложение
**Входные данные:** Многократное обращение к `Instance`
**Ожидаемый результат:** Один и тот же объект возвращается

**Test ID:** `CFG-005`
**Что проверяет:** Загрузка списка "шумных" доменов
**Для чего:** Фильтрация CDN/telemetry в UI
**Критерий успеха:** Список загружается из конфига/встроенного ресурса
**Входные данные:** Конфиг с доменами `*.googleapis.com`, `*.microsoft.com`
**Ожидаемый результат:** `IsNoise("fonts.googleapis.com")` возвращает `true`

---

## 9. Error Handling & Edge Cases

### 9.1 Network Errors
**Test ID:** `ERR-001`
**Что проверяет:** Обработка сетевого таймаута
**Для чего:** Graceful handling при недоступности сети
**Критерий успеха:** Исключение логируется, процесс продолжается
**Входные данные:** Хост с таймаутом DNS/TCP
**Ожидаемый результат:** `TestResult` с соответствующим статусом, без crash

**Test ID:** `ERR-002`
**Что проверяет:** Обработка VPN-конфликта
**Для чего:** Предупреждение пользователя о возможных проблемах
**Критерий успеха:** Warning в логе при обнаружении TAP/TUN адаптера
**Входные данные:** Активный VPN-адаптер
**Ожидаемый результат:** Предупреждение в UI/логе

**Test ID:** `ERR-003`
**Что проверяет:** Обработка отсутствия прав администратора
**Для чего:** Информативное сообщение пользователю
**Критерий успеха:** Приложение не запускается, выводится сообщение
**Входные данные:** Запуск без UAC elevation
**Ожидаемый результат:** MessageBox с требованием прав администратора

### 9.2 Resource Cleanup
**Test ID:** `ERR-004`
**Что проверяет:** Корректное освобождение WinDivert-хэндлов
**Для чего:** Избежать утечек ресурсов
**Критерий успеха:** Все хэндлы закрываются при остановке
**Входные данные:** Запуск/остановка TrafficEngine
**Ожидаемый результат:** `WinDivertClose()` вызывается для всех handle

**Test ID:** `ERR-005`
**Что проверяет:** Cleanup фильтров при исключении
**Для чего:** Не оставлять зависшие фильтры в системе
**Критерий успеха:** `finally` блоки отрабатывают, фильтры удаляются
**Входные данные:** Исключение во время работы фильтра
**Ожидаемый результат:** Фильтр удалён из `TrafficEngine.ActiveFilters`

### 9.3 Edge Cases
**Test ID:** `ERR-006`
**Что проверяет:** Обработка DoH-трафика (DNS over HTTPS)
**Для чего:** Корректное поведение при недоступности DNS-снифинга
**Критерий успеха:** Приложение работает, но без SNI для DoH-хостов
**Входные данные:** Браузер с включённым DoH
**Ожидаемый результат:** Хосты определяются по IP, без hostname

**Test ID:** `ERR-007`
**Что проверяет:** Обработка IPv6-адресов
**Для чего:** Поддержка IPv6-трафика
**Критерий успеха:** IPv6-адреса парсятся и тестируются корректно
**Входные данные:** Соединение на IPv6-хост
**Ожидаемый результат:** `TestResult` с IPv6-адресом

**Test ID:** `ERR-008`
**Что проверяет:** Обработка экстремально длинного ClientHello (>1500 байт)
**Для чего:** Проверка работы фрагментации на больших пакетах
**Критерий успеха:** Фрагментация выполняется без переполнения буфера
**Входные данные:** ClientHello длиной 2000 байт
**Ожидаемый результат:** Несколько TCP-сегментов, данные не повреждены

---

## 10. Integration & End-to-End

### 10.1 Full Pipeline
**Test ID:** `E2E-001`
**Что проверяет:** Полный цикл: Capture → Test → Classify → UI
**Для чего:** Проверка всей цепочки обработки
**Критерий успеха:** Карточка появляется в UI с корректным диагнозом
**Входные данные:** Соединение к заблокированному хосту
**Ожидаемый результат:** Карточка в UI с типом блокировки и рекомендацией

**Test ID:** `E2E-002`
**Что проверяет:** Bypass включается и работает
**Для чего:** Проверка end-to-end работы обхода
**Критерий успеха:** После включения bypass соединение устанавливается
**Входные данные:** Заблокированный хост, включение TLS Fragment
**Ожидаемый результат:** Метрики показывают фрагментацию, соединение успешно

**Test ID:** `E2E-003`
**Что проверяет:** Auto-bypass при обнаружении блокировки
**Для чего:** Преемптивное включение обхода
**Критерий успеха:** Bypass включается автоматически при DPI_FILTER
**Входные данные:** DPI-блокировка с включённым auto-bypass
**Ожидаемый результат:** `TlsBypassService.ApplyPreemptiveAsync()` вызывается, UI показывает активный bypass

### 10.2 Process Attach
**Test ID:** `E2E-004`
**Что проверяет:** Attach к запущенному процессу (Steam)
**Для чего:** Проверка динамического подключения
**Критерий успеха:** PID добавляется, трафик отслеживается
**Входные данные:** PID уже запущенного Steam
**Ожидаемый результат:** Соединения Steam появляются в UI

**Test ID:** `E2E-005`
**Что проверяет:** Обработка завершения целевого процесса
**Для чего:** Корректное поведение при закрытии приложения
**Критерий успеха:** Orchestrator останавливает мониторинг
**Входные данные:** Целевой процесс закрывается
**Ожидаемый результат:** Логируется событие, мониторинг останавливается

---

## 11. Performance & Stability

### 11.1 Load Testing
**Test ID:** `PERF-001`
**Что проверяет:** Обработка множества соединений (>100/сек)
**Для чего:** Проверка производительности при высокой нагрузке
**Критерий успеха:** Pipeline не блокируется, очереди не переполняются
**Входные данные:** Симуляция 500 соединений за 5 секунд
**Ожидаемый результат:** [PipelineHealth] показывает стабильные счётчики, latency < 1s

**Test ID:** `PERF-002`
**Что проверяет:** Утечки памяти при длительной работе (>1 час)
**Для чего:** Проверка стабильности при долгом мониторинге
**Критерий успеха:** Потребление памяти не растёт линейно
**Входные данные:** Запуск на 1+ час с периодическим трафиком
**Ожидаемый результат:** Memory footprint стабилизируется после 15-20 минут

### 11.2 Concurrency
**Test ID:** `PERF-003`
**Что проверяет:** Thread-safety компонентов (InMemoryBlockageStateStore)
**Для чего:** Проверка корректности при многопоточном доступе
**Критерий успеха:** Нет race conditions, данные не повреждаются
**Входные данные:** Параллельные записи в store из 10+ потоков
**Ожидаемый результат:** Все записи корректны, нет исключений

---

## 12. Regression Tests

### 12.1 Known Issues
**Test ID:** `REG-001`
**Что проверяет:** Кракозябры в tracert (CP866)
**Для чего:** Проверка исправления известного бага
**Критерий успеха:** Русские символы отображаются корректно
**Входные данные:** Вывод tracert на русском Windows
**Ожидаемый результат:** Текст читаемый, без �

**Test ID:** `REG-002`
**Что проверяет:** VPN-конфликт (дублирование пакетов)
**Для чего:** Проверка, что warning выводится
**Критерий успеха:** Пользователь предупреждён о возможных проблемах
**Входные данные:** Активный VPN
**Ожидаемый результат:** Warning в логе/UI

**Test ID:** `REG-003`
**Что проверяет:** Persist/restore apply-транзакций без WPF (console smoke)
**Для чего:** Регресс-гейт: последняя транзакция должна сохраняться и восстанавливаться (для репорта/отладки)
**Критерий успеха:** После записи транзакции появляется JSON, и новый BypassController видит её в ApplyTransactions
**Входные данные:** Синтетическая транзакция (hostKey/groupKey + endpoints)
**Ожидаемый результат:** ApplyTransactions.Count > 0 после reload

**Test ID:** `REG-009`
**Что проверяет:** Apply-транзакция содержит контракт (request/snapshot/result/contributions)
**Для чего:** Регресс-гейт P0.1 Step 2: формат транзакции должен быть структурным и расширяемым (не только плоские поля v1)
**Критерий успеха:** В exported JSON присутствуют секции `request`, `snapshot`, `result`, `contributions` и при этом сохранены ключевые v1 поля (например `candidateIpEndpoints`, `activationStatus`)
**Входные данные:** Синтетическая транзакция через `BypassController.RecordApplyTransaction`
**Ожидаемый результат:** JSON валиден и содержит все нужные секции

**Test ID:** `REG-010`
**Что проверяет:** В apply-транзакции корректно сохраняется `result.Status` (например `APPLIED`)
**Для чего:** Регресс-гейт наблюдаемости: статус результата должен быть управляемым и отражать фактический исход (не только значение по умолчанию)
**Критерий успеха:** В exported JSON поле `result.Status` равно `APPLIED` при явной передаче этого статуса
**Входные данные:** Синтетическая транзакция через `BypassController.RecordApplyTransaction(..., resultStatus: "APPLIED")`
**Ожидаемый результат:** JSON валиден и содержит `result.Status=APPLIED`

**Test ID:** `REG-011`
**Что проверяет:** В apply-транзакции сохраняются поля ошибок/отката (`result.Error`, `result.RollbackStatus`) и поддерживаются статусы `FAILED`/`CANCELED`
**Для чего:** Регресс-гейт наблюдаемости: при отмене/ошибке должно быть видно не только факт записи, но и исход apply + результат отката
**Критерий успеха:** Exported JSON содержит `result.Status` = `FAILED`/`CANCELED`, `result.Error` (для FAILED) и `result.RollbackStatus` (например `DONE`)
**Входные данные:** Синтетические транзакции через `BypassController.RecordApplyTransaction(..., resultStatus: "FAILED", error: "...", rollbackStatus: "DONE")`
**Ожидаемый результат:** JSON валиден и содержит указанные поля

**Test ID:** `REG-012`
**Что проверяет:** Операции ручного применения плана сериализованы (нет параллельного apply)
**Для чего:** Исключить гонки и частично применённые состояния при двойном клике/нескольких apply-командах подряд
**Критерий успеха:** Два конкурентных вызова `BypassController.ApplyIntelPlanAsync` выполняются последовательно (по времени выполнения при тестовой задержке)
**Входные данные:** Два `ApplyIntelPlanAsync` в `Task.WhenAll` при `ISP_AUDIT_TEST_APPLY_DELAY_MS=250`
**Ожидаемый результат:** Время выполнения >= ~500ms (с допуском)

**Test ID:** `REG-013`
**Что проверяет:** Детерминированный merge состояния группы в `GroupBypassAttachmentStore` (endpoints=union, assist-флаги=OR) и «sticky excluded»
**Для чего:** Регресс-гейт P0.1 Step 14: единый источник истины по группе не должен терять ручное исключение и должен собирать итоговую конфигурацию детерминированно
**Критерий успеха:** `CandidateIpEndpointsUnion` содержит union endpoint-ов и отсортирован; `DropUdp443/AllowNoSni` = OR по attachments; excluded host не становится included после UpdateAttachmentFromApply/Pin
**Входные данные:** In-memory сценарий: два hostKey (один excluded), два apply (с разными plan tokens и endpoints)
**Ожидаемый результат:** AttachmentCount=2, Included=1, Excluded=1, union endpoints=2, флаги OR=true, excluded не сброшен

**Test ID:** `REG-014`
**Что проверяет:** Round-trip сохранения/загрузки `%LocalAppData%\ISP_Audit\group_participation.json` через `GroupBypassAttachmentStore` (overridePath)
**Для чего:** Регресс-гейт P0.1 Step 15: участие/пиннинг должны переживать перезапуск приложения и не зависеть от UI-level словарей
**Критерий успеха:** После persist+reload восстанавливаются pinning `hostKey -> groupKey` и ручные excluded hostKey для группы
**Входные данные:** In-memory store + временный путь файла (temp), pinning двух hostKey и excluded одного hostKey
**Ожидаемый результат:** `TryGetPinnedGroupKey` возвращает ожидаемый groupKey для обоих hostKey; `IsExcluded` true только для исключённого hostKey

**Test ID:** `REG-015`
**Что проверяет:** observed IPv4 цели засеваются из candidate endpoints (P0.2 Stage 5.4)
**Для чего:** Per-target политики (DstIpv4Set) могут компилироваться сразу, без ожидания DNS resolve
**Критерий успеха:** После seed из `1.2.3.4:443` и `5.6.7.8:80` snapshot содержит оба IPv4 адреса
**Входные данные:** Вызов internal API `BypassStateManager.SeedObservedIpv4TargetsFromCandidateEndpointsBestEffort(...)`
**Ожидаемый результат:** Snapshot содержит ожидаемые IPv4 адреса (в network-order uint)

**Test ID:** `REG-016`
**Что проверяет:** ApplyIntelPlanAsync timeout содержит фазовую диагностику (cancelReason/currentPhase/phases)
**Для чего:** P0.2 наблюдаемость: при таймауте Apply нужно понимать, на какой фазе зависло/отменилось (без ручного репро)
**Критерий успеха:** При детерминированном таймауте `CancelReason=timeout`, а также заполнены `CurrentPhase` и список `Phases` (включая `test_delay`)
**Входные данные:** `ISP_AUDIT_TEST_APPLY_DELAY_MS=500` и `timeout=50ms` при вызове `BypassController.ApplyIntelPlanAsync`
**Ожидаемый результат:** Бросается `BypassApplyCanceledException`, в `Execution` присутствует фазовая диагностика

**Test ID:** `REG-017`
**Что проверяет:** QUIC/HTTP3 диагностика и рекомендация QUIC fallback (DropUdp443)
**Для чего:** Регресс-гейт: отличать QUIC/HTTP3 проблему от TCP/TLS. При H3 fail без TCP/TLS ошибок должен появляться assist DropUdp443, а при TLS timeout — не должен.
**Критерий успеха:** DiagnosisId=QuicInterference для H3-fail-only сигналов; план содержит `DropUdp443=true`. При `HasTlsTimeout=true` план НЕ содержит `DropUdp443`.
**Входные данные:** Синтетические `BlockageSignals` (H3 attempts>0, ok=0, fail>0, notSupported=0) в двух вариантах: без TLS timeout и с TLS timeout.
**Ожидаемый результат:** Соответствие диагнозов/assist-флага ожидаемой логике

**Test ID:** `REG-004`
**Что проверяет:** Per-card ретест во время диагностики ставится в очередь и флашится после завершения
**Для чего:** Регресс-гейт UX: кнопка «Ретест» не должна быть «мертвой» во время диагностики
**Критерий успеха:** Во время IsRunning выставляется статус «запланирован», после flush очередь очищается и статус обновляется
**Входные данные:** Синтетическая карточка + эмуляция IsDiagnosticRunning через smoke reflection
**Ожидаемый результат:** Очередь очищена, ActionStatusText содержит «очередь»

**Test ID:** `REG-005`
**Что проверяет:** QUIC fallback (селективно) поддерживает несколько активных целей и не «забывает» предыдущую при применении новой
**Для чего:** Регресс-гейт для P0.1 Step 1: при последовательном применении разных сервисов selective DropUdp443 остаётся эффективным для обоих
**Критерий успеха:** После второго применения количество целевых IPv4 для drop UDP/443 увеличивается (union), а не заменяется
**Входные данные:** Два разных OutcomeTargetHost (например, 1.1.1.1 и 2.2.2.2), режим без TrafficEngine (no admin), чтение snapshot через smoke reflection
**Ожидаемый результат:** TargetIpCount после второго применения >= TargetIpCount после первого + 1

**Test ID:** `REG-006`
**Что проверяет:** TCP/443 TLS стратегия выбирается per-target (multi-group) через Decision Graph по dst_ip
**Для чего:** Регресс-гейт для P0.1 Step 1: после последовательного применения разных сервисов TCP/443 стратегия не должна «перетерать» предыдущую — выбор должен быть по признакам пакета
**Критерий успеха:** Для двух разных IPv4 назначаются разные TLS стратегии при EvaluateTcp443TlsClientHello (policy-driven)
**Входные данные:** Два OutcomeTargetHost (например, 1.1.1.1 и 2.2.2.2) + два плана (TlsFragment и TlsDisorder), режим без TrafficEngine (no admin), чтение DecisionGraphSnapshot через smoke reflection
**Ожидаемый результат:** Для 1.1.1.1 выбирается Fragment, для 2.2.2.2 — Disorder

**Test ID:** `REG-007`
**Что проверяет:** TCP/80 HTTP Host tricks выбирается per-target (multi-group) через Decision Graph по dst_ip
**Для чего:** Регресс-гейт для P0.1 Step 1: при нескольких активных целях policy `HttpHostTricks` должна матчиться по `dst_ip` (per-target `tcp80_http_host_tricks_<hostKey>`), чтобы не расширять blast radius.
**Критерий успеха:** Для двух разных IPv4 выбираются разные per-target политики при Evaluate (по candidates + MatchCondition.DstIpv4Set)
**Входные данные:** Два OutcomeTargetHost (например, 1.1.1.1 и 2.2.2.2) + два плана (HttpHostTricks), режим без TrafficEngine (no admin), чтение DecisionGraphSnapshot через smoke reflection
**Ожидаемый результат:** Для 1.1.1.1 выбирается policy `tcp80_http_host_tricks_1_1_1_1`, для 2.2.2.2 — `tcp80_http_host_tricks_2_2_2_2`

**Test ID:** `REG-008`
**Что проверяет:** Capabilities union для TLS (Fragment/Disorder): применение к цели B не выключает ранее нужные capabilities цели A
**Для чего:** Дополнительный регресс-гейт к P0.1 Step 1: при multi-target применении нужно удерживать необходимые техники включёнными одновременно (union), а выбор «какая именно» техника должна происходить по decision graph.
**Критерий успеха:** После двух apply (Fragment→A, Disorder→B) в effective options остаются включены и `FragmentEnabled`, и `DisorderEnabled`
**Входные данные:** Два OutcomeTargetHost (например, 1.1.1.1 и 2.2.2.2) + два плана (TlsFragment и TlsDisorder), режим без TrafficEngine (no admin), чтение `BypassStateManager.GetOptionsSnapshot()`
**Ожидаемый результат:** `FragmentEnabled=true` и `DisorderEnabled=true`

---

## Приоритизация тестов

### Critical (Must Pass) — Блокируют релиз
- `INFRA-001`, `INFRA-004` (драйвер и права)
- `PIPE-001`, `PIPE-002`, `PIPE-003` (захват трафика, PID, SNI)
- `BYPASS-001`, `BYPASS-006` (включение bypass, фрагментация)
- `E2E-001` (полный цикл)
- `ERR-003` (обработка отсутствия прав)

### High Priority — Важные функции
- `PIPE-008` до `PIPE-011` (тестирование)
- `PIPE-012` до `PIPE-016` (классификация)
- `BYPASS-003`, `BYPASS-004` (метрики и вердикты)
- `DPI2-004`, `DPI2-007` (диагностика и selector)
- `UI-001`, `UI-004`, `UI-008` (UI-логика)

### Medium Priority — Расширенный функционал
- `INSP-001` до `INSP-005` (инспекционные сервисы)
- `BYPASS-007` до `BYPASS-011` (расширенные стратегии)
- `DPI2-001`, `DPI2-002` (signals)
- `ORCH-003`, `ORCH-004` (SNI gating)

### Low Priority — Nice to Have
- `PERF-001`, `PERF-002` (нагрузочное тестирование)
- `ERR-006` (DoH)
- `REG-001` (кракозябры)

---

## Инфраструктура для smoke-тестов

### Требования к окружению
1. **Windows 10/11** с правами администратора
2. **WinDivert 2.2.0** в PATH или рядом с exe
3. **.NET 9 Runtime**
4. **Тестовые хосты:**
   - Доступный: `google.com`, `cloudflare.com`
   - Заблокированный (для тестирования DPI): настраиваемый через конфиг
   - Fake IP (198.18.x.x): mock DNS-сервер

### Формат запуска
```bash
# Полный набор
ISP_Audit.exe --smoke-test all

# Конкретная категория
ISP_Audit.exe --smoke-test infrastructure

# Конкретный тест
ISP_Audit.exe --smoke-test INFRA-001

# UI-reducer smoke
TestNetworkApp.exe --ui-reducer-smoke
```

### Ожидаемый вывод
```
[SMOKE] Running test INFRA-001: WinDivert Driver Loading
[SMOKE] ✓ PASSED (120ms)
[SMOKE] Running test PIPE-003: SNI Parsing
[SMOKE] ✓ PASSED (45ms)
...
[SMOKE] Summary: 85/90 passed, 3 skipped, 2 failed
[SMOKE] Failed tests: BYPASS-013 (Auto TTL), E2E-003 (Auto-bypass)
```

---

## Автоматизация

### CI/CD Pipeline
1. **Pre-commit:** Критические тесты (5 мин)
2. **PR:** High + Medium (10 мин)
3. **Nightly:** Full suite (30 мин)
4. **Release:** Full + Load testing (1 час)

### Мониторинг
- Логирование всех тестов в `smoke_test_results.json`
- Dashboard с трендами (сколько тестов проходит за последние N билдов)
- Alerting при падении критических тестов с `DPI_FILTER`, `confidence = 80`
