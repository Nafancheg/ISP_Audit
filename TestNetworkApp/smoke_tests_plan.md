# ISP_Audit v3.0 — План Smoke-тестов

**Дата:** 18.12.2025  
**Цель:** Быстрая проверка критического функционала без полного GUI запуска  
**Время выполнения:** ~5-10 минут на полный набор

---

## 1. Infrastructure Layer (Инфраструктура)

### 1.1 WinDivert Driver
**Test ID:** `INFRA-001`  
**Что проверяет:** Загрузка драйвера WinDivert  
**Для чего:** Без драйвера вся система не работает  
**Критерий успеха:** Драйвер загружается без ошибок, возвращает handle  
**Входные данные:** Нет  
**Ожидаемый результат:** `TrafficEngine.Initialize()` возвращает `true`

**Test ID:** `INFRA-002`  
**Что проверяет:** Регистрация фильтра в TrafficEngine  
**Для чего:** Проверка механизма добавления/удаления фильтров  
**Критерий успеха:** Фильтр добавляется в список активных  
**Входные данные:** Dummy-фильтр  
**Ожидаемый результат:** Фильтр присутствует в `ActiveFilters`

**Test ID:** `INFRA-003`  
**Что проверяет:** Порядок выполнения фильтров (пассивные → модифицирующие)  
**Для чего:** Критично для корректного снятия метрик до модификации  
**Критерий успеха:** `TrafficMonitorFilter` вызывается раньше `BypassFilter`  
**Входные данные:** Два фильтра с разными приоритетами  
**Ожидаемый результат:** Счетчики вызовов подтверждают порядок

### 1.2 Права доступа
**Test ID:** `INFRA-004`  
**Что проверяет:** Наличие прав администратора  
**Для чего:** WinDivert требует UAC elevation  
**Критерий успеха:** Текущий процесс имеет Admin-роль  
**Входные данные:** Нет  
**Ожидаемый результат:** `WindowsPrincipal.IsInRole(Administrator) == true`

### 1.3 Кодировки
**Test ID:** `INFRA-005`  
**Что проверяет:** Регистрация CP866 (OEM) для `tracert`  
**Для чего:** Без этого русские символы в tracert превращаются в кракозябры  
**Критерий успеха:** `Encoding.GetEncoding(866)` не выбрасывает исключение  
**Входные данные:** Нет  
**Ожидаемый результат:** Кодировка доступна после `Encoding.RegisterProvider`

---

## 2. Core Pipeline (Конвейер обработки)

### 2.1 Traffic Collection
**Test ID:** `PIPE-001`  
**Что проверяет:** Захват SYN-пакетов через ConnectionMonitorService  
**Для чего:** Проверка, что система видит новые соединения  
**Критерий успеха:** События соединений публикуются при подключении  
**Входные данные:** Открытие TCP-соединения на известный хост  
**Ожидаемый результат:** `ConnectionMonitor` вызывает callback с `remote_endpoint`

**Test ID:** `PIPE-002`  
**Что проверяет:** PID-фильтрация в TrafficCollector  
**Для чего:** Убедиться, что трафик фильтруется по целевому процессу  
**Критерий успеха:** Пакеты от других процессов игнорируются  
**Входные данные:** Трафик от 2+ процессов, фильтр по одному PID  
**Ожидаемый результат:** В пайплайн попадают только пакеты целевого PID

**Test ID:** `PIPE-003`  
**Что проверяет:** SNI-парсинг из TLS ClientHello  
**Для чего:** Извлечение доменного имени для отображения в UI  
**Критерий успеха:** SNI извлекается из цельного и фрагментированного ClientHello  
**Входные данные:** TLS ClientHello для `example.com` (цельный и разбитый на 2 сегмента)  
**Ожидаемый результат:** `DnsParserService` возвращает `example.com`

**Test ID:** `PIPE-004`  
**Что проверяет:** Корреляция SNI с PID через remote endpoint  
**Для чего:** Гейтирование SNI по целевому процессу (без PID в WinDivert Network Layer)  
**Критерий успеха:** SNI проходит в пайплайн только если endpoint совпадает с отслеживаемым PID  
**Входные данные:** SNI-событие для хоста + события соединений с разными PID  
**Ожидаемый результат:** Orchestrator пропускает только релевантные SNI

### 2.2 Filtering & Validation
**Test ID:** `PIPE-005`  
**Что проверяет:** UnifiedTrafficFilter отбрасывает loopback  
**Для чего:** Не создавать карточки для 127.0.0.1  
**Критерий успеха:** Локальные адреса не попадают в UI  
**Входные данные:** `127.0.0.1`, `::1`  
**Ожидаемый результат:** Фильтр возвращает `false`

**Test ID:** `PIPE-006`  
**Что проверяет:** NoiseHostFilter применяется только на этапе отображения  
**Для чего:** Не терять сигнал на браузерных/CDN-сценариях при pre-check  
**Критерий успеха:** Хост тестируется, но не показывается в UI если Status=OK  
**Входные данные:** `fonts.googleapis.com` (успешное соединение)  
**Ожидаемый результат:** Тест выполнен, но карточка не создана

**Test ID:** `PIPE-007`  
**Что проверяет:** Дедупликация хостов в InMemoryBlockageStateStore  
**Для чего:** Не тестировать один хост многократно за сессию  
**Критерий успеха:** Повторная проверка игнорируется  
**Входные данные:** 2 события для `example.com` подряд  
**Ожидаемый результат:** Только первое попадает в тестер

### 2.3 Testing
**Test ID:** `PIPE-008`  
**Что проверяет:** DNS-резолв через StandardHostTester  
**Для чего:** Проверка базовой доступности домена  
**Критерий успеха:** Возвращаются IP-адреса для существующего домена  
**Входные данные:** `google.com`  
**Ожидаемый результат:** `DnsResult.IsSuccess == true`, список IP не пуст

**Test ID:** `PIPE-009`  
**Что проверяет:** TCP Handshake (SYN → SYN-ACK)  
**Для чего:** Проверка TCP-доступности  
**Критерий успеха:** Соединение устанавливается с доступным хостом  
**Входные данные:** `google.com:443`  
**Ожидаемый результат:** `TcpResult.IsSuccess == true`

**Test ID:** `PIPE-010`  
**Что проверяет:** TLS ClientHello → ServerHello  
**Для чего:** Проверка DPI-блокировок на уровне TLS/SNI  
**Критерий успеха:** ServerHello получен от доступного хоста  
**Входные данные:** `google.com:443` с SNI  
**Ожидаемый результат:** `TlsResult.IsSuccess == true`

**Test ID:** `PIPE-011`  
**Что проверяет:** Reverse DNS (PTR) для IP  
**Для чего:** Дополнительная информация для UI (техническое поле)  
**Критерий успеха:** PTR-запрос выполняется (даже если результат пустой)  
**Входные данные:** `8.8.8.8`  
**Ожидаемый результат:** `rDnsResult` содержит hostname или null без exception

### 2.4 Classification
**Test ID:** `PIPE-012`  
**Что проверяет:** Классификация DNS-блокировки  
**Для чего:** Определение типа проблемы  
**Критерий успеха:** Вердикт `DNS_BLOCKED` при ошибке DNS  
**Входные данные:** `HostTested` с `DnsResult.IsSuccess == false`  
**Ожидаемый результат:** `BlockageType == DNS_BLOCKED`

**Test ID:** `PIPE-013`  
**Что проверяет:** Классификация TCP Timeout  
**Для чего:** Определение Drop-блокировки  
**Критерий успеха:** Вердикт `TCP_CONNECT_TIMEOUT` при таймауте TCP  
**Входные данные:** `HostTested` с `TcpResult.TimedOut == true`  
**Ожидаемый результат:** `BlockageType == TCP_CONNECT_TIMEOUT`

**Test ID:** `PIPE-014`  
**Что проверяет:** Классификация TCP Reset  
**Для чего:** Определение активной блокировки  
**Критерий успеха:** Вердикт `TCP_RESET` при получении RST  
**Входные данные:** `HostTested` с `TcpResult.ReceivedReset == true`  
**Ожидаемый результат:** `BlockageType == TCP_RESET`

**Test ID:** `PIPE-015`  
**Что проверяет:** Классификация DPI_FILTER (TLS-блокировка)  
**Для чего:** Определение SNI-фильтрации  
**Критерий успеха:** Вердикт `DPI_FILTER` при TLS timeout/reset  
**Входные данные:** `HostTested` с успешным TCP, но неудачным TLS  
**Ожидаемый результат:** `BlockageType == DPI_FILTER`

**Test ID:** `PIPE-016`  
**Что проверяет:** Классификация FAKE_IP (редирект на 198.18.x.x)  
**Для чего:** Определение редиректов через роутер/шлюз  
**Критерий успеха:** Вердикт `FAKE_IP` при получении адреса из диапазона 198.18.0.0/15  
**Входные данные:** DNS-ответ с IP `198.18.0.1`  
**Ожидаемый результат:** `BlockageType == FAKE_IP`, рекомендация `ROUTER_REDIRECT`

### 2.5 Pipeline Health
**Test ID:** `PIPE-017`  
**Что проверяет:** Периодический [PipelineHealth] лог  
**Для чего:** Диагностика затыков/потерь данных в очередях  
**Критерий успеха:** Лог выводится каждые N секунд с счётчиками этапов  
**Входные данные:** Запущенный пайплайн  
**Ожидаемый результат:** Строка вида `[PipelineHealth] enqueue:10 test:9 classify:9 ui:8`

---

## 3. Inspection Services (Глубокий анализ)

### 3.1 RST Inspection
**Test ID:** `INSP-001`  
**Что проверяет:** Обнаружение RST Injection по TTL  
**Для чего:** Отличить легитимный RST от инжектированного DPI  
**Критерий успеха:** RST с аномальным TTL помечается как injection  
**Входные данные:** RST-пакет с TTL=5 при обычном TTL=64  
**Ожидаемый результат:** `RstInspectionService` логирует injection

**Test ID:** `INSP-002`  
**Что проверяет:** Сравнение IP Identification  
**Для чего:** Дополнительная эвристика для RST injection  
**Критерий успеха:** Аномальный IP ID помечается как подозрительный  
**Входные данные:** RST с IP ID сильно отличающимся от предыдущих пакетов  
**Ожидаемый результат:** Warning в логе инспектора

### 3.2 UDP/QUIC Inspection
**Test ID:** `INSP-003`  
**Что проверяет:** Обнаружение блокировки QUIC  
**Для чего:** Провайдеры часто блокируют QUIC для форсирования HTTP/TLS  
**Критерий успеха:** UDP-трафик на 443 с QUIC-сигнатурой детектируется  
**Входные данные:** QUIC Initial packet на UDP:443  
**Ожидаемый результат:** `UdpInspectionService` детектирует QUIC и проверяет доступность

### 3.3 Retransmission Tracking
**Test ID:** `INSP-004`  
**Что проверяет:** Подсчёт TCP-ретрансмиссий  
**Для чего:** Обнаружение Packet Drop (тихий дроп)  
**Критерий успеха:** Высокий % ретрансмиссий (>10%) фиксируется  
**Входные данные:** TCP-поток с 15% повторных отправок  
**Ожидаемый результат:** `TcpRetransmissionTracker` логирует подозрение на Drop

### 3.4 HTTP Redirect Detection
**Test ID:** `INSP-005`  
**Что проверяет:** Обнаружение редиректа на blockpage  
**Для чего:** Определение метода блокировки через HTTP 301/302  
**Критерий успеха:** Редирект на известную заглушку детектируется  
**Входные данные:** HTTP 302 на `http://warning.rt.ru`  
**Ожидаемый результат:** `HttpRedirectDetector` классифицирует как blockpage

---

## 4. Bypass Layer (Обход блокировок)

### 4.1 TlsBypassService
**Test ID:** `BYPASS-001`  
**Что проверяет:** Регистрация BypassFilter в TrafficEngine  
**Для чего:** Проверка, что обход включается корректно  
**Критерий успеха:** Фильтр добавляется при `ApplyOptionsAsync`  
**Входные данные:** Опции обхода с `TlsFragmentationEnabled = true`  
**Ожидаемый результат:** `BypassFilter` присутствует в `TrafficEngine.ActiveFilters`

**Test ID:** `BYPASS-002`  
**Что проверяет:** Удаление BypassFilter при отключении  
**Для чего:** Проверка корректного cleanup  
**Критерий успеха:** Фильтр удаляется при `DisableBypassAsync`  
**Входные данные:** Активный обход  
**Ожидаемый результат:** `BypassFilter` отсутствует в `TrafficEngine.ActiveFilters`

**Test ID:** `BYPASS-003`  
**Что проверяет:** Сбор метрик фильтра (каждые 2 сек)  
**Для чего:** Отслеживание работы обхода в UI  
**Критерий успеха:** Событие `MetricsUpdated` публикуется периодически  
**Входные данные:** Включённый bypass с TLS-трафиком  
**Ожидаемый результат:** Метрики содержат `ClientHelloSeen`, `Fragmented`, `RstCount`

**Test ID:** `BYPASS-004`  
**Что проверяет:** Вычисление вердикта (зелёный/жёлтый/красный)  
**Для чего:** Индикация эффективности обхода  
**Критерий успеха:** Правильная классификация по соотношению RST/фрагментаций  
**Входные данные:** Метрики с ratio > 4 (красный), 1.5-4 (жёлтый), < 1.5 (зелёный)  
**Ожидаемый результат:** Событие `VerdictChanged` с корректным цветом

**Test ID:** `BYPASS-005`  
**Что проверяет:** Загрузка/сохранение пресетов из `bypass_profile.json`  
**Для чего:** Персистентность настроек между запусками  
**Критерий успеха:** Выбранный пресет и параметры восстанавливаются  
**Входные данные:** Профиль с `PresetName = "Aggressive"`  
**Ожидаемый результат:** `TlsBypassService` загружает параметры агрессивного пресета

### 4.2 BypassFilter
**Test ID:** `BYPASS-006`  
**Что проверяет:** Фрагментация TLS ClientHello  
**Для чего:** Базовая стратегия обхода DPI  
**Критерий успеха:** ClientHello разбивается на 2+ TCP-сегмента  
**Входные данные:** ClientHello длиной 300 байт, пресет `[80, 220]`  
**Ожидаемый результат:** 2 TCP-сегмента с корректными seq/len, метрика `Fragmented++`

**Test ID:** `BYPASS-007`  
**Что проверяет:** Disorder (обратный порядок сегментов)  
**Для чего:** Усложнённая стратегия обхода  
**Критерий успеха:** Сегменты отправляются в обратном порядке с корректными seq  
**Входные данные:** ClientHello с опцией `TlsDisorderEnabled`  
**Ожидаемый результат:** Сегменты идут в обратном порядке, данные валидны при реассемблинге

**Test ID:** `BYPASS-008`  
**Что проверяет:** Fake TTL (фейковый пакет с коротким TTL)  
**Для чего:** Обман DPI без доставки пакета до сервера  
**Критерий успеха:** Фейковый пакет отправляется с TTL < реального  
**Входные данные:** ClientHello с опцией `FakeTtlEnabled`, `FakeTtlValue = 5`  
**Ожидаемый результат:** 2 пакета: fake (TTL=5) и real (TTL=64)

**Test ID:** `BYPASS-009`  
**Что проверяет:** Drop RST (блокировка входящих RST)  
**Для чего:** Игнорирование инжектированных reset-ов от DPI  
**Критерий успеха:** RST-пакеты не доходят до приложения  
**Входные данные:** Входящий RST-пакет с опцией `DropRstEnabled`  
**Ожидаемый результат:** Метрика `RstDropped++`, RST не передаётся дальше

**Test ID:** `BYPASS-010`  
**Что проверяет:** Фильтрация по порту 443 и наличию SNI  
**Для чего:** Обрабатывать только релевантный TLS-трафик  
**Критерий успеха:** Пакеты не на 443 или без SNI игнорируются  
**Входные данные:** ClientHello на порт 80, ClientHello:443 без SNI  
**Ожидаемый результат:** Метрики `Non443++`, `NoSni++`, фрагментация не выполняется

**Test ID:** `BYPASS-011`  
**Что проверяет:** Порог длины ClientHello (threshold)  
**Для чего:** Не фрагментировать короткие ClientHello  
**Критерий успеха:** Пакеты < threshold не фрагментируются  
**Входные данные:** ClientHello длиной 50 байт, threshold = 100  
**Ожидаемый результат:** Метрика `ShortClientHello++`, пакет проходит без изменений

### 4.3 TTL Trick & Auto-adjust
**Test ID:** `BYPASS-012`  
**Что проверяет:** Ручное включение TTL Trick  
**Для чего:** Пользовательская настройка TTL для обхода  
**Критерий успеха:** TTL применяется к исходящим пакетам  
**Входные данные:** `TtlTrickEnabled = true`, `TtlTrickValue = 10`  
**Ожидаемый результат:** Исходящие пакеты имеют TTL = 10

**Test ID:** `BYPASS-013`  
**Что проверяет:** Автоподбор TTL (`AutoTtlEnabled`)  
**Для чего:** Автоматическое нахождение оптимального TTL  
**Критерий успеха:** Сервис перебирает значения и выбирает лучшее  
**Входные данные:** `AutoTtlEnabled = true`, набор {5, 10, 15, 20}  
**Ожидаемый результат:** Лучший TTL сохраняется в `bypass_profile.json`

**Test ID:** `BYPASS-014`  
**Что проверяет:** Автокоррекция минимального чанка (Aggressive)  
**Для чего:** Адаптация к DPI при всплеске RST  
**Критерий успеха:** Минимальный чанк ужимается до 4 при раннем всплеске  
**Входные данные:** Пресет Aggressive, много RST в первые секунды  
**Ожидаемый результат:** `MinChunkSize` уменьшается, опции переприменяются

**Test ID:** `BYPASS-015`  
**Что проверяет:** Релаксация чанка при стабильном зелёном (>30s)  
**Для чего:** Постепенное снижение агрессивности при успехе  
**Критерий успеха:** Минимальный чанк слегка уменьшается (не ниже 4)  
**Входные данные:** Стабильный зелёный статус >30 секунд  
**Ожидаемый результат:** `MinChunkSize` немного уменьшается, опции переприменяются

---

## 5. DPI Intelligence v2

### 5.1 Signals Collection
**Test ID:** `DPI2-001`  
**Что проверяет:** Адаптация legacy сигналов в SignalsAdapterV2  
**Для чего:** Преобразование legacy `BlockageSignals` в v2-формат  
**Критерий успеха:** События добавляются в TTL-store  
**Входные данные:** `BlockageSignals` с `BlockageType = TCP_RESET`  
**Ожидаемый результат:** `SignalsAdapterV2.Observe()` создаёт `SignalEvent` и добавляет в store

**Test ID:** `DPI2-002`  
**Что проверяет:** TTL событий (10 минут)  
**Для чего:** Очистка старых событий из памяти  
**Критерий успеха:** События старше 10 минут удаляются  
**Входные данные:** События с timestamp > 10 минут назад  
**Ожидаемый результат:** `TTLBlockageStateStore.Append()` удаляет старые события

**Test ID:** `DPI2-003`  
**Что проверяет:** Агрегация событий по окну (30s default, 60s extended)  
**Для чего:** Построение среза `BlockageSignalsV2` для диагностики  
**Критерий успеха:** Агрегированные признаки считаются корректно  
**Входные данные:** 10 событий за 25 секунд (timeout/rst/retx)  
**Ожидаемый результат:** `BuildAggregatedSignals()` возвращает срез с правильными счётчиками

**Test ID:** `DPI2-016`  
**Что проверяет:** Извлечение `RstTtlDelta` и `RstLatency` в `BuildSnapshot`  
**Для чего:** Устойчивые улики для `ActiveDpiEdge/StatefulDpi` (RST TTL delta/latency)  
**Критерий успеха:** `RstTtlDelta` вычисляется из строки инспектора, `RstLatency` берётся из TCP latency  
**Входные данные:** `TCP_CONNECTION_RESET` + `HasSuspiciousRst=true` + `SuspiciousRstDetails="TTL=64 (обычный=50-55)"` + `TcpLatencyMs=120`  
**Ожидаемый результат:** `RstTtlDelta=9`, `RstLatency≈120ms`

### 5.2 Diagnosis Engine
**Test ID:** `DPI2-004`  
**Что проверяет:** Постановка диагноза по `BlockageSignalsV2`  
**Для чего:** Определение типа блокировки и уверенности  
**Критерий успеха:** Диагноз с `confidence >= 50` формируется  
**Входные данные:** `BlockageSignalsV2` с высоким retx-rate и timeout  
**Ожидаемый результат:** `StandardDiagnosisEngineV2.Diagnose()` возвращает `DiagnosisId.SilentDrop`, `confidence > 50`

**Test ID:** `DPI2-017`  
**Что проверяет:** `RST TTL delta + fast` классифицируется как `ActiveDpiEdge`  
**Для чего:** Уменьшить долю `Unknown` при RST-инъекциях  
**Критерий успеха:** Диагноз `ActiveDpiEdge` и `confidence >= 60`  
**Входные данные:** `HasTcpReset=true`, `RstTtlDelta=10`, `RstLatency=120ms`  
**Ожидаемый результат:** `DiagnosisId.ActiveDpiEdge`

**Test ID:** `DPI2-018`  
**Что проверяет:** `RST TTL delta + slow` классифицируется как `StatefulDpi`  
**Для чего:** Разделять активную инъекцию и stateful инспекцию  
**Критерий успеха:** Диагноз `StatefulDpi` и `confidence >= 60`  
**Входные данные:** `HasTcpReset=true`, `RstTtlDelta=10`, `RstLatency=900ms`  
**Ожидаемый результат:** `DiagnosisId.StatefulDpi`

**Test ID:** `DPI2-005`  
**Что проверяет:** Формирование пояснения (без упоминания стратегий)  
**Для чего:** Пользователю понятно "что не так" без технического жаргона  
**Критерий успеха:** Пояснение содержит факты (timeout, retx), но не стратегии  
**Входные данные:** Диагноз `DPI_FILTER` (DPI фильтрация)  
**Ожидаемый результат:** Explanation вида "TLS ClientHello не доходит, высокий timeout на 443"

**Test ID:** `DPI2-006`  
**Что проверяет:** Gate 1→2 маркеры в логе `[V2][GATE1]`  
**Для чего:** Проверка корректности перехода от сбора к диагностике  
**Критерий успеха:** Маркеры появляются в UI-логе при каждом переходе  
**Входные данные:** Успешное построение `BlockageSignalsV2`  
**Ожидаемый результат:** Строка `[V2][GATE1] host=example.com events=5 window=30s`

### 5.3 Strategy Selector
**Test ID:** `DPI2-007`  
**Что проверяет:** Построение `BypassPlan` по `DiagnosisResult`  
**Для чего:** Рекомендации пользователю по обходу  
**Критерий успеха:** План содержит стратегии для диагноза  
**Входные данные:** `DiagnosisResult` + `BypassPlan`  
**Ожидаемый результат:** Строка вида `[V2] example.com: DPI_FILTER (80%) - TLS фильтрация, рекомендуется: Fragment+Disorder`

**Test ID:** `DPI2-014`  
**Что проверяет:** Ранжирование стратегий по feedback поверх basePriority  
**Для чего:** Улучшать порядок рекомендаций на основе успешности  
**Критерий успеха:** При достаточной выборке успешная стратегия поднимается выше  
**Входные данные:** Feedback (ActiveDpiEdge + TlsFragment=Success, ActiveDpiEdge + TlsDisorder=Failure)  
**Ожидаемый результат:** Первой в плане становится `TlsFragment` (при стабильном успехе)

**Test ID:** `DPI2-015`  
**Что проверяет:** Feedback не влияет при малой выборке  
**Для чего:** Не реагировать на шум/случайные единичные исходы  
**Критерий успеха:** При total < MinSamples порядок остаётся как по basePriority  
**Входные данные:** Feedback с 4 событиями успеха  
**Ожидаемый результат:** Первой остаётся `TlsDisorder` (basePriority=90)

**Test ID:** `DPI2-012`  
**Что проверяет:** Префикс `[V2]` во всех выводах  
**Для чего:** Отличить v2-рекомендации от legacy  
**Критерий успеха:** Все строки рекомендаций v2 начинаются с `[V2]`  
**Входные данные:** Любой v2-вывод  
**Ожидаемый результат:** Префикс `[V2]` присутствует

**Test ID:** `DPI2-013`  
**Что проверяет:** Отсутствие auto-apply в MVP  
**Для чего:** Применение обхода только вручную пользователем  
**Критерий успеха:** Executor не вызывает `TrafficEngine` или `BypassController`  
**Входные данные:** Любой `BypassPlan`  
**Ожидаемый результат:** Только логирование, никаких вызовов bypass-методов

### 5.4 Executor v2 (Manual Apply)
**Test ID:** `DPI2-019`  
**Что проверяет:** Ручное применение `BypassPlan` корректно маппит стратегии в bypass-опции  
**Для чего:** Гарантировать, что v2-plan действительно приводит к нужным настройкам (без auto-apply)  
**Критерий успеха:** После применения включены ожидаемые флаги (например, `TLS_FRAGMENT`, `DROP_RST`)  
**Входные данные:** `BypassPlan` с `TlsFragment` + `DropRst`  
**Ожидаемый результат:** `BypassController` отражает включённые опции

**Test ID:** `DPI2-022`  
**Что проверяет:** Параметры `TlsFragment` из `BypassPlan` реально влияют на выбранный пресет и `AutoAdjustAggressive`  
**Для чего:** Executor должен применять то, что описано в плане (детерминизм), а не текущее UI-состояние  
**Критерий успеха:** После применения выбран пресет по sizes и включён `AutoAdjustAggressive=true`  
**Входные данные:** `BypassPlan` с `TlsFragment.Parameters: { TlsFragmentSizes=[32,32], AutoAdjustAggressive=true }`  
**Ожидаемый результат:** `SelectedFragmentPreset.Sizes == [32,32]`, `IsAutoAdjustAggressive == true`

**Test ID:** `DPI2-023`  
**Что проверяет:** Селектор v2 кладёт параметры `TlsFragment` (PresetName/TlsFragmentSizes) прямо в `BypassPlan`  
**Для чего:** Детерминизм: executor не должен зависеть от текущего пресета пользователя  
**Критерий успеха:** В плане у `TlsFragment` присутствуют `PresetName` и `TlsFragmentSizes`  
**Входные данные:** `DiagnosisResult(SilentDrop, confidence=80)`  
**Ожидаемый результат:** `plan.Strategies[].Parameters` содержит `PresetName="Стандарт"` и `TlsFragmentSizes=[64]`

**Test ID:** `DPI2-024`  
**Что проверяет:** E2E цепочку `selector → plan → ApplyV2PlanAsync` (параметры из плана реально применяются)  
**Для чего:** Самый важный функциональный контракт: рекомендации v2 должны быть исполнимы и детерминированы  
**Критерий успеха:** После apply включены ожидаемые флаги и выбран ожидаемый пресет/размеры из параметров плана  
**Входные данные:** `DiagnosisResult(SilentDrop, confidence=80)` → `StandardStrategySelectorV2.Select(...)`  
**Ожидаемый результат:** `IsFragmentEnabled=true`, `IsDropRstEnabled=true`, `SelectedFragmentPreset.Name=="Стандарт"`, sizes `[64]`, `AutoAdjustAggressive=false`

**Test ID:** `DPI2-020`  
**Что проверяет:** Отмена/таймаут применения приводит к безопасному откату (rollback)  
**Для чего:** Не оставлять систему в частично применённом состоянии при Cancel/Timeout  
**Критерий успеха:** Состояние после отмены совпадает со snapshot до применения  
**Входные данные:** Включённая исходная опция + `CancellationToken` с быстрым Cancel  
**Ожидаемый результат:** Выбрасывается `OperationCanceledException`, опции откатываются

**Test ID:** `DPI2-021`  
**Что проверяет:** Pipeline v2 не делает auto-apply (только строит/публикует план)  
**Для чего:** Применение обхода должно быть строго по клику пользователя  
**Критерий успеха:** В IL `LiveTestingPipeline` нет вызовов к `BypassController`/`TlsBypassService`  
**Входные данные:** Рефлексия/IL-анализ `LiveTestingPipeline`  
**Ожидаемый результат:** Запрещённых вызовов не обнаружено

---

## 6. UI Layer (WPF)

### 6.1 MainViewModelRefactored
**Test ID:** `UI-001`  
**Что проверяет:** Инициализация DiagnosticOrchestrator  
**Для чего:** Проверка создания всех зависимостей  
**Критерий успеха:** Orchestrator создаётся без исключений  
**Входные данные:** ViewModel при старте  
**Ожидаемый результат:** `orchestrator != null`, сервисы инициализированы

**Test ID:** `UI-002`  
**Что проверяет:** Обработка команды Start/Stop  
**Для чего:** Проверка запуска/остановки диагностики  
**Критерий успеха:** Pipeline запускается/останавливается  
**Входные данные:** Клик на кнопку "Старт"  
**Ожидаемый результат:** `orchestrator.StartAsync()` вызывается, UI обновляется

**Test ID:** `UI-003`  
**Что проверяет:** Обработка ошибок (async void)  
**Для чего:** Проверка, что исключения не проглатываются  
**Критерий успеха:** Ошибка отображается в UI  
**Входные данные:** Исключение в async void методе  
**Ожидаемый результат:** MessageBox или лог с ошибкой

### 6.2 BypassController
**Test ID:** `UI-004`  
**Что проверяет:** Биндинг UI-тумблеров к TlsBypassService  
**Для чего:** Синхронизация состояния UI с сервисом  
**Критерий успеха:** Изменение тумблера вызывает метод сервиса  
**Входные данные:** Включение "Fragment" в UI  
**Ожидаемый результат:** `TlsBypassService.ApplyOptionsAsync()` вызывается с `TlsFragmentationEnabled = true`

**Test ID:** `UI-005`  
**Что проверяет:** Загрузка/сохранение пресета в `bypass_profile.json`  
**Для чего:** Персистентность настроек  
**Критерий успеха:** Выбранный пресет восстанавливается при запуске  
**Входные данные:** Профиль с выбранным пресетом  
**Ожидаемый результат:** `BypassController` восстанавливает пресет без перезаписи TTL/redirect rules

**Test ID:** `UI-006`  
**Что проверяет:** Отображение метрик bypass (план фрагментации, timestamp)  
**Для чего:** Визуализация работы обхода  
**Критерий успеха:** Метрики обновляются из событий `TlsBypassService`  
**Входные данные:** Событие `MetricsUpdated`  
**Ожидаемый результат:** UI показывает план фрагментации, активный пресет, минимальный чанк

**Test ID:** `UI-007`  
**Что проверяет:** Подсветка карточки по вердикту (зелёный/жёлтый/красный)  
**Для чего:** Визуальная индикация эффективности  
**Критерий успеха:** Карточка меняет цвет в зависимости от статуса  
**Входные данные:** Событие `VerdictChanged` с красным статусом  
**Ожидаемый результат:** Карточка подсвечивается красным, серые статусы не подсвечиваются

### 6.3 TestResultsManager
**Test ID:** `UI-008`  
**Что проверяет:** Добавление результата в ObservableCollection  
**Для чего:** Отображение новой карточки в UI  
**Критерий успеха:** Карточка появляется в списке  
**Входные данные:** `TestResult` с проблемой  
**Ожидаемый результат:** `ObservableCollection` содержит новый элемент

**Test ID:** `UI-009`  
**Что проверяет:** Обновление существующей карточки  
**Для чего:** Избежать дублирования карточек для одного хоста  
**Критерий успеха:** Существующая карточка обновляется  
**Входные данные:** Повторный `TestResult` для того же хоста  
**Ожидаемый результат:** Количество карточек не увеличивается, данные обновлены

**Test ID:** `UI-010`  
**Что проверяет:** Парсинг строк пайплайна (`ParsePipelineMessage`)  
**Для чего:** Преобразование лог-строк в UI-модели  
**Критерий успеха:** Строки корректно парсятся  
**Входные данные:** Строки вида `[Classification] host=example.com type=TCP_RESET`  
**Ожидаемый результат:** `TestResult` с корректными полями

**Test ID:** `UI-011`  
**Что проверяет:** UI-Reducer smoke-режим (`--ui-reducer-smoke`)  
**Для чего:** Воспроизводимая проверка детерминизма UI без GUI  
**Критерий успеха:** Типовые строки обрабатываются без исключений  
**Входные данные:** Набор типовых лог-строк пайплайна  
**Ожидаемый результат:** Все строки парсятся, результаты логируются

**Test ID:** `UI-012`  
**Что проверяет:** Приоритет SNI/hostname над IP в ключе карточки  
**Для чего:** Человеко-понятное отображение  
**Критерий успеха:** Ключ карточки использует hostname, если известен  
**Входные данные:** Событие с IP и hostname  
**Ожидаемый результат:** Карточка отображает `example.com`, а не `93.184.216.34`

---

## 7. Orchestration & Process Tracking

### 7.1 DiagnosticOrchestrator
**Test ID:** `ORCH-001`  
**Что проверяет:** Запуск/остановка LiveTestingPipeline  
**Для чего:** Управление жизненным циклом пайплайна  
**Критерий успеха:** Pipeline запускается/останавливается корректно  
**Входные данные:** `StartAsync()` / `StopAsync()`  
**Ожидаемый результат:** Pipeline в соответствующем состоянии

**Test ID:** `ORCH-002`  
**Что проверяет:** Управление фоновыми сервисами (TrafficEngine, ConnectionMonitor)  
**Для чего:** Инициализация/cleanup сервисов  
**Критерий успеха:** Сервисы запускаются/останавливаются вместе с orchestrator  
**Входные данные:** Старт orchestrator  
**Ожидаемый результат:** `TrafficEngine.Initialize()` и `ConnectionMonitor.Start()` вызываются

**Test ID:** `ORCH-003`  
**Что проверяет:** Гейтирование SNI по PID  
**Для чего:** Фильтрация SNI для целевого процесса  
**Критерий успеха:** Только SNI от целевого процесса попадают в пайплайн  
**Входные данные:** SNI-события от разных процессов, фильтр по одному PID  
**Ожидаемый результат:** Только SNI с remote endpoint, принадлежащим целевому PID, проходят дальше

**Test ID:** `ORCH-004`  
**Что проверяет:** Буфер ранних SNI для Steam/attach сценариев  
**Для чего:** Не терять SNI, пришедший до появления PID  
**Критерий успеха:** SNI сохраняется в буфере на несколько секунд  
**Входные данные:** SNI до события соединения с PID  
**Ожидаемый результат:** SNI проходит в пайплайн после появления соответствующего PID

**Test ID:** `ORCH-005`  
**Что проверяет:** Отслеживание целевых процессов (PidTrackerService)  
**Для чего:** Мониторинг жизненного цикла целевого процесса  
**Критерий успеха:** Orchestrator реагирует на завершение процесса  
**Входные данные:** Целевой процесс завершается  
**Ожидаемый результат:** Orchestrator логирует событие или останавливает мониторинг

### 7.2 PidTrackerService
**Test ID:** `ORCH-006`  
**Что проверяет:** Добавление/удаление PID из отслеживаемых  
**Для чего:** Динамическое управление списком целевых процессов  
**Критерий успеха:** PID добавляется/удаляется корректно  
**Входные данные:** `AddPid(1234)` / `RemovePid(1234)`  
**Ожидаемый результат:** `TrackedPids` содержит/не содержит PID

**Test ID:** `ORCH-007`  
**Что проверяет:** Проверка принадлежности PID к отслеживаемым  
**Для чего:** Быстрая фильтрация событий  
**Критерий успеха:** Метод `IsPidTracked()` возвращает правильный результат  
**Входные данные:** PID в списке и вне списка  
**Ожидаемый результат:** `true` для отслеживаемого, `false` для остальных

---

## 8. Configuration & Persistence

### 8.1 Config (Global State)
**Test ID:** `CFG-001`  
**Что проверяет:** Загрузка `bypass_profile.json`  
**Для чего:** Восстановление настроек обхода  
**Критерий успеха:** Профиль загружается без ошибок  
**Входные данные:** Валидный JSON-файл  
**Ожидаемый результат:** `Config.ActiveProfile` содержит данные из файла

**Test ID:** `CFG-002`  
**Что проверяет:** Сохранение изменений в профиль  
**Для чего:** Персистентность настроек между запусками  
**Критерий успеха:** Изменения записываются в файл  
**Входные данные:** Изменённый пресет  
**Ожидаемый результат:** JSON-файл обновлён, новые значения присутствуют

**Test ID:** `CFG-003`  
**Что проверяет:** Обработка некорректного JSON  
**Для чего:** Graceful degradation при повреждённом файле  
**Критерий успеха:** Приложение не крашится, используется дефолтный профиль  
**Входные данные:** Повреждённый JSON  
**Ожидаемый результат:** Warning в логе, дефолтные настройки применены

### 8.2 NoiseHostFilter
**Test ID:** `CFG-004`  
**Что проверяет:** Singleton-паттерн (`NoiseHostFilter.Instance`)  
**Для чего:** Единая точка доступа к фильтру  
**Критерий успеха:** Один экземпляр на всё приложение  
**Входные данные:** Многократное обращение к `Instance`  
**Ожидаемый результат:** Один и тот же объект возвращается

**Test ID:** `CFG-005`  
**Что проверяет:** Загрузка списка "шумных" доменов  
**Для чего:** Фильтрация CDN/telemetry в UI  
**Критерий успеха:** Список загружается из конфига/встроенного ресурса  
**Входные данные:** Конфиг с доменами `*.googleapis.com`, `*.microsoft.com`  
**Ожидаемый результат:** `IsNoise("fonts.googleapis.com")` возвращает `true`

---

## 9. Error Handling & Edge Cases

### 9.1 Network Errors
**Test ID:** `ERR-001`  
**Что проверяет:** Обработка сетевого таймаута  
**Для чего:** Graceful handling при недоступности сети  
**Критерий успеха:** Исключение логируется, процесс продолжается  
**Входные данные:** Хост с таймаутом DNS/TCP  
**Ожидаемый результат:** `TestResult` с соответствующим статусом, без crash

**Test ID:** `ERR-002`  
**Что проверяет:** Обработка VPN-конфликта  
**Для чего:** Предупреждение пользователя о возможных проблемах  
**Критерий успеха:** Warning в логе при обнаружении TAP/TUN адаптера  
**Входные данные:** Активный VPN-адаптер  
**Ожидаемый результат:** Предупреждение в UI/логе

**Test ID:** `ERR-003`  
**Что проверяет:** Обработка отсутствия прав администратора  
**Для чего:** Информативное сообщение пользователю  
**Критерий успеха:** Приложение не запускается, выводится сообщение  
**Входные данные:** Запуск без UAC elevation  
**Ожидаемый результат:** MessageBox с требованием прав администратора

### 9.2 Resource Cleanup
**Test ID:** `ERR-004`  
**Что проверяет:** Корректное освобождение WinDivert-хэндлов  
**Для чего:** Избежать утечек ресурсов  
**Критерий успеха:** Все хэндлы закрываются при остановке  
**Входные данные:** Запуск/остановка TrafficEngine  
**Ожидаемый результат:** `WinDivertClose()` вызывается для всех handle

**Test ID:** `ERR-005`  
**Что проверяет:** Cleanup фильтров при исключении  
**Для чего:** Не оставлять зависшие фильтры в системе  
**Критерий успеха:** `finally` блоки отрабатывают, фильтры удаляются  
**Входные данные:** Исключение во время работы фильтра  
**Ожидаемый результат:** Фильтр удалён из `TrafficEngine.ActiveFilters`

### 9.3 Edge Cases
**Test ID:** `ERR-006`  
**Что проверяет:** Обработка DoH-трафика (DNS over HTTPS)  
**Для чего:** Корректное поведение при недоступности DNS-снифинга  
**Критерий успеха:** Приложение работает, но без SNI для DoH-хостов  
**Входные данные:** Браузер с включённым DoH  
**Ожидаемый результат:** Хосты определяются по IP, без hostname

**Test ID:** `ERR-007`  
**Что проверяет:** Обработка IPv6-адресов  
**Для чего:** Поддержка IPv6-трафика  
**Критерий успеха:** IPv6-адреса парсятся и тестируются корректно  
**Входные данные:** Соединение на IPv6-хост  
**Ожидаемый результат:** `TestResult` с IPv6-адресом

**Test ID:** `ERR-008`  
**Что проверяет:** Обработка экстремально длинного ClientHello (>1500 байт)  
**Для чего:** Проверка работы фрагментации на больших пакетах  
**Критерий успеха:** Фрагментация выполняется без переполнения буфера  
**Входные данные:** ClientHello длиной 2000 байт  
**Ожидаемый результат:** Несколько TCP-сегментов, данные не повреждены

---

## 10. Integration & End-to-End

### 10.1 Full Pipeline
**Test ID:** `E2E-001`  
**Что проверяет:** Полный цикл: Capture → Test → Classify → UI  
**Для чего:** Проверка всей цепочки обработки  
**Критерий успеха:** Карточка появляется в UI с корректным диагнозом  
**Входные данные:** Соединение к заблокированному хосту  
**Ожидаемый результат:** Карточка в UI с типом блокировки и рекомендацией

**Test ID:** `E2E-002`  
**Что проверяет:** Bypass включается и работает  
**Для чего:** Проверка end-to-end работы обхода  
**Критерий успеха:** После включения bypass соединение устанавливается  
**Входные данные:** Заблокированный хост, включение TLS Fragment  
**Ожидаемый результат:** Метрики показывают фрагментацию, соединение успешно

**Test ID:** `E2E-003`  
**Что проверяет:** Auto-bypass при обнаружении блокировки  
**Для чего:** Преемптивное включение обхода  
**Критерий успеха:** Bypass включается автоматически при DPI_FILTER  
**Входные данные:** DPI-блокировка с включённым auto-bypass  
**Ожидаемый результат:** `TlsBypassService.ApplyPreemptiveAsync()` вызывается, UI показывает активный bypass

### 10.2 Process Attach
**Test ID:** `E2E-004`  
**Что проверяет:** Attach к запущенному процессу (Steam)  
**Для чего:** Проверка динамического подключения  
**Критерий успеха:** PID добавляется, трафик отслеживается  
**Входные данные:** PID уже запущенного Steam  
**Ожидаемый результат:** Соединения Steam появляются в UI

**Test ID:** `E2E-005`  
**Что проверяет:** Обработка завершения целевого процесса  
**Для чего:** Корректное поведение при закрытии приложения  
**Критерий успеха:** Orchestrator останавливает мониторинг  
**Входные данные:** Целевой процесс закрывается  
**Ожидаемый результат:** Логируется событие, мониторинг останавливается

---

## 11. Performance & Stability

### 11.1 Load Testing
**Test ID:** `PERF-001`  
**Что проверяет:** Обработка множества соединений (>100/сек)  
**Для чего:** Проверка производительности при высокой нагрузке  
**Критерий успеха:** Pipeline не блокируется, очереди не переполняются  
**Входные данные:** Симуляция 500 соединений за 5 секунд  
**Ожидаемый результат:** [PipelineHealth] показывает стабильные счётчики, latency < 1s

**Test ID:** `PERF-002`  
**Что проверяет:** Утечки памяти при длительной работе (>1 час)  
**Для чего:** Проверка стабильности при долгом мониторинге  
**Критерий успеха:** Потребление памяти не растёт линейно  
**Входные данные:** Запуск на 1+ час с периодическим трафиком  
**Ожидаемый результат:** Memory footprint стабилизируется после 15-20 минут

### 11.2 Concurrency
**Test ID:** `PERF-003`  
**Что проверяет:** Thread-safety компонентов (InMemoryBlockageStateStore)  
**Для чего:** Проверка корректности при многопоточном доступе  
**Критерий успеха:** Нет race conditions, данные не повреждаются  
**Входные данные:** Параллельные записи в store из 10+ потоков  
**Ожидаемый результат:** Все записи корректны, нет исключений

---

## 12. Regression Tests

### 12.1 Known Issues
**Test ID:** `REG-001`  
**Что проверяет:** Кракозябры в tracert (CP866)  
**Для чего:** Проверка исправления известного бага  
**Критерий успеха:** Русские символы отображаются корректно  
**Входные данные:** Вывод tracert на русском Windows  
**Ожидаемый результат:** Текст читаемый, без �

**Test ID:** `REG-002`  
**Что проверяет:** VPN-конфликт (дублирование пакетов)  
**Для чего:** Проверка, что warning выводится  
**Критерий успеха:** Пользователь предупреждён о возможных проблемах  
**Входные данные:** Активный VPN  
**Ожидаемый результат:** Warning в логе/UI

---

## Приоритизация тестов

### Critical (Must Pass) — Блокируют релиз
- `INFRA-001`, `INFRA-004` (драйвер и права)
- `PIPE-001`, `PIPE-002`, `PIPE-003` (захват трафика, PID, SNI)
- `BYPASS-001`, `BYPASS-006` (включение bypass, фрагментация)
- `E2E-001` (полный цикл)
- `ERR-003` (обработка отсутствия прав)

### High Priority — Важные функции
- `PIPE-008` до `PIPE-011` (тестирование)
- `PIPE-012` до `PIPE-016` (классификация)
- `BYPASS-003`, `BYPASS-004` (метрики и вердикты)
- `DPI2-004`, `DPI2-007` (диагностика v2 и selector)
- `UI-001`, `UI-004`, `UI-008` (UI-логика)

### Medium Priority — Расширенный функционал
- `INSP-001` до `INSP-005` (инспекционные сервисы)
- `BYPASS-007` до `BYPASS-011` (расширенные стратегии)
- `DPI2-001`, `DPI2-002` (signals v2)
- `ORCH-003`, `ORCH-004` (SNI gating)

### Low Priority — Nice to Have
- `PERF-001`, `PERF-002` (нагрузочное тестирование)
- `ERR-006` (DoH)
- `REG-001` (кракозябры)

---

## Инфраструктура для smoke-тестов

### Требования к окружению
1. **Windows 10/11** с правами администратора
2. **WinDivert 2.2.0** в PATH или рядом с exe
3. **.NET 9 Runtime**
4. **Тестовые хосты:**
   - Доступный: `google.com`, `cloudflare.com`
   - Заблокированный (для тестирования DPI): настраиваемый через конфиг
   - Fake IP (198.18.x.x): mock DNS-сервер

### Формат запуска
```bash
# Полный набор
ISP_Audit.exe --smoke-test all

# Конкретная категория
ISP_Audit.exe --smoke-test infrastructure

# Конкретный тест
ISP_Audit.exe --smoke-test INFRA-001

# UI-reducer smoke
TestNetworkApp.exe --ui-reducer-smoke
```

### Ожидаемый вывод
```
[SMOKE] Running test INFRA-001: WinDivert Driver Loading
[SMOKE] ✓ PASSED (120ms)
[SMOKE] Running test PIPE-003: SNI Parsing
[SMOKE] ✓ PASSED (45ms)
...
[SMOKE] Summary: 85/90 passed, 3 skipped, 2 failed
[SMOKE] Failed tests: BYPASS-013 (Auto TTL), E2E-003 (Auto-bypass)
```

---

## Автоматизация

### CI/CD Pipeline
1. **Pre-commit:** Критические тесты (5 мин)
2. **PR:** High + Medium (10 мин)
3. **Nightly:** Full suite (30 мин)
4. **Release:** Full + Load testing (1 час)

### Мониторинг
- Логирование всех тестов в `smoke_test_results.json`
- Dashboard с трендами (сколько тестов проходит за последние N билдов)
- Alerting при падении критических тестов с `DPI_FILTER`, `confidence = 80`  
**Ожидаемый результат:** `StandardStrategySelectorV2.Select()` возвращает план с `TLS_FRAGMENT`, `TLS_DISORDER`

**Test ID:** `DPI2-008`  
**Что проверяет:** Блокировка `RiskLevel.High` при `confidence < 70`  
**Для чего:** Не применять агрессивные стратегии при низкой уверенности  
**Критерий успеха:** High-risk стратегии отсутствуют в плане  
**Входные данные:** `DiagnosisResult` с `confidence = 60`  
**Ожидаемый результат:** План не содержит стратегий с `RiskLevel.High`

**Test ID:** `DPI2-009`  
**Что проверяет:** Пустой план при `confidence < 50`  
**Для чего:** Не давать рекомендаций при слишком низкой уверенности  
**Критерий успеха:** План пустой или содержит только `NONE`  
**Входные данные:** `DiagnosisResult` с `confidence = 40`  
**Ожидаемый результат:** `BypassPlan.Strategies.IsEmpty == true`

**Test ID:** `DPI2-010`  
**Что проверяет:** Warning при нереализованных стратегиях  
**Для чего:** Не ломать пайплайн на будущих стратегиях  
**Критерий успеха:** Предупреждение в лог, стратегия пропускается  
**Входные данных:** `BypassPlan` с `StrategyId.FutureStrategy`  
**Ожидаемый результат:** Warning в логе, стратегия не включена

### 5.4 Executor MVP
**Test ID:** `DPI2-011`  
**Что проверяет:** Форматирование вывода для UI (1-2 строки)  
**Для чего:** Компактный вывод рекомендаций без спама  
**Критерий успеха:** Вывод содержит диагноз + уверенность + короткое объяснение  
**Входные данные:** `DiagnosisResult`