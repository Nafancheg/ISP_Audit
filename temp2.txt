            var tcpPortal = tcpAll.Where(r => r.port == 80 || r.port == 443).ToList();
            if (tcpPortal.Count == 0)
                summary.tcp_portal = "UNKNOWN";
            else if (tcpPortal.All(r => r.open))
                summary.tcp_portal = "OK";
            else if (tcpPortal.Any(r => r.open))
                summary.tcp_portal = "WARN"; // Частично доступен
            else
                summary.tcp_portal = "FAIL";

            // TCP Launcher (8000-8020) - патчер/лаунчер Star Citizen
            var tcpLauncher = tcpAll.Where(r => r.port >= 8000 && r.port <= 8020).ToList();
            if (tcpLauncher.Count == 0)
                summary.tcp_launcher = "UNKNOWN";
            else if (tcpLauncher.All(r => r.open))
                summary.tcp_launcher = "OK";
            else if (tcpLauncher.Any(r => r.open))
                summary.tcp_launcher = "WARN"; // Частично доступен
            else
                summary.tcp_launcher = "FAIL";

            if (run.udp_tests == null || run.udp_tests.Count == 0)
            {
                summary.udp = "UNKNOWN";
            }
            else
            {
                // Check high-certainty tests (expect_reply=true) first
                var highCertaintyTests = run.udp_tests.Where(r => r.certainty == "high" || r.expect_reply).ToList();
                if (highCertaintyTests.Count > 0)
                {
                    bool fail = highCertaintyTests.Any(r => !r.success);
                    bool ok = highCertaintyTests.Any(r => r.success);
                    summary.udp = fail ? "FAIL" : (ok ? "OK" : "UNKNOWN");
                }
                else
                {
                    // Only low-certainty tests (raw probes without replies)
                    summary.udp = "INFO"; // Informational only, can't confirm connectivity
                }
            }

            var httpTargets = run.targets.Values.Where(t => t.http_enabled).ToList();
            if (httpTargets.Count == 0)
            {
                summary.tls = "UNKNOWN";
            }
            else
            {
                bool anyTlsOk = false;
                bool suspect = false;
                bool mitm = false; // Certificate CN mismatch - potential MITM attack
                bool blockPage = false; // Block page detected

                foreach (var t in httpTargets)
                {
                    bool tcp443Open = t.tcp_enabled && t.tcp.Any(r => r.port == 443 && r.open);
                    bool httpOk = t.http.Any(h => h.success && h.status is >= 200 and < 400);

                    // Check for certificate CN mismatch (MITM detection)
                    bool cnMismatch = t.http.Any(h => h.cert_cn != null && h.cert_cn_matches == false);
                    if (cnMismatch) mitm = true;

                    // Check for block pages
                    bool isBlockPage = t.http.Any(h => h.is_block_page == true);
                    if (isBlockPage) blockPage = true;

                    if (httpOk) anyTlsOk = true;
                    if (tcp443Open && !httpOk) suspect = true;
                }

                // Priority: BLOCK_PAGE > MITM > SUSPECT > FAIL > OK
                if (blockPage)
                    summary.tls = "BLOCK_PAGE";
                else if (mitm)
                    summary.tls = "MITM_SUSPECT";
                else if (suspect)
                    summary.tls = "SUSPECT";
                else if (anyTlsOk)
                    summary.tls = "OK";
                else
                    summary.tls = "FAIL";
            }

            if (run.rst_heuristic == null) summary.rst_inject = "UNKNOWN";
            else summary.rst_inject = "UNKNOWN";

            return summary;
        }

        public static string BuildAdviceText(RunReport run)
        {
            var lines = new List<string>();
            string FormatTarget(KeyValuePair<string, TargetReport> kv)
                => string.IsNullOrWhiteSpace(kv.Value.service) ? kv.Key : $"{kv.Key} ({kv.Value.service})";
            var udpTests = run.udp_tests ?? new List<UdpProbeResult>();

            var dnsBadTargets = run.targets
                .Where(kv => kv.Value.dns_enabled && (kv.Value.dns_status == nameof(DnsStatus.DNS_BOGUS) || kv.Value.dns_status == nameof(DnsStatus.DNS_FILTERED)))
                .Select(FormatTarget)
                .ToList();
            if (dnsBadTargets.Count > 0)
            {
                lines.Add($"DNS: обнаружены проблемы у сервисов: {string.Join(", ", dnsBadTargets)}.");
                lines.Add("— Системный DNS пуст или возвращает приватные/некорректные адреса. Возможна фильтрация провайдером или некорректный локальный DNS.");
                lines.Add("— Сравните результаты с DoH (Cloudflare) и при необходимости переключите лаунчер/игру на DoH/DoT или альтернативный резолвер.");
                lines.Add("— Обход: DoH/DoT, DNSCrypt, VPN, либо локальный резолвер (unbound) с TLS.");
            }
            else if (run.summary.dns == nameof(DnsStatus.WARN))
            {
                var warnTargets = run.targets
                    .Where(kv => kv.Value.dns_enabled && kv.Value.dns_status == nameof(DnsStatus.WARN))
                    .Select(FormatTarget)
                    .ToList();
                var suffix = warnTargets.Count > 0 ? $" ({string.Join(", ", warnTargets)})" : string.Empty;
                lines.Add($"DNS: предупреждение{suffix} — системный и DoH ответы не совпадают.");
                lines.Add("— Это может быть нормально (CDN с геолокацией), или вы находитесь за корпоративным прокси/NAT.");
                lines.Add("— Если игра работает — всё в порядке. Если нет — возможна подмена DNS провайдером.");
            }

