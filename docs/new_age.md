# Policy-Driven Execution Plane: Архитектурный подход для систем обхода сетевых ограничений

**Дата**: 15.01.2026  
**Статус**: Architecture Proposal  
**Контекст**: ISP Audit — система обхода блокировок на основе WinDivert

---

## Введение

Данный документ описывает архитектурный подход к построению систем обхода сетевых ограничений, основанный на признании фундаментальных ограничений платформы перехвата пакетов как базовых принципов проектирования, а не временных препятствий.

---

## Ключевой тезис

**Обход блокировок — это не состояние системы. Обход — это функция от пакета.**

Попытки управлять "активными обходами", "сессиями" или "владельцами конфигурации" приводят к архитектурным противоречиям, потому что противоречат физической природе работы систем перехвата пакетов.

---

## Фундаментальные ограничения (законы природы)

### Закон 1: Пакет перехватывается один раз
WinDivert (и аналогичные системы) захватывает пакет из сетевого стека **один раз**. После захвата пакет находится в пространстве пользователя и должен быть либо возвращён в стек (модифицированным или как есть), либо отброшен.

**Следствие**: к одному пакету можно применить **одну атомарную операцию**, а не композицию операций.

### Закон 2: Фильтры статичны и не знают контекста
Фильтры WinDivert описываются синтаксисом условий на поля пакетов. Фильтр не может "узнать", что пакет относится к "YouTube" или "Discord" — он видит только IP, порт, протокол.

**Следствие**: нельзя написать фильтр "для приложения X". Можно написать фильтр "для пакетов к IP из множества Y".

### Закон 3: Стратегии обхода могут быть взаимоисключающими
Некоторые техники обхода физически несовместимы: блокировка UDP/443 исключает любую модификацию UDP/443; фрагментация пакета несовместима с его отбрасыванием.

**Следствие**: нельзя "объединить стратегии" для одного потока трафика.

### Закон 4: Современные приложения — это распределённые системы
YouTube, Discord, Steam — не один домен, а десятки взаимосвязанных сервисов с разными хостами, требующими разных техник обхода.

**Следствие**: нельзя "применить обход к YouTube" как к единой сущности.

---

## Архитектурные слои

Архитектура строится на четырёх чётко разделённых слоях абстракции, каждый из которых решает свою задачу и не вмешивается в смежные.

```
┌─────────────────────────────────────┐
│  Semantic Layer                     │  ← Пользовательская семантика
│  (Applications, Groups)             │
└──────────────┬──────────────────────┘
               │ expands to
┌──────────────▼──────────────────────┐
│  Policy Layer                       │  ← Декларативные правила
│  (Flow Policies)                    │
└──────────────┬──────────────────────┘
               │ compiled to
┌──────────────▼──────────────────────┐
│  Decision Graph                     │  ← Детерминированный выбор
│  (Runtime Decision Engine)          │
└──────────────┬──────────────────────┘
               │ executed by
┌──────────────▼──────────────────────┐
│  Execution Plane                    │  ← Обработка пакетов
│  (WinDivert Handlers)               │
└─────────────────────────────────────┘
```

---

## 1. Execution Plane (уровень обработки пакетов)

### Назначение
Непосредственная обработка перехваченных пакетов. Это единственный слой, который взаимодействует с WinDivert.

### Принципы

**Статичность фильтров**: фильтры WinDivert создаются по схеме "один хендлер на протокол-порт" и не меняются в процессе работы.

Примеры:
- `tcp.DstPort == 443` → Tcp443Handler
- `udp.DstPort == 443` → Udp443Handler
- `tcp.DstPort == 80` → Tcp80Handler

**Отсутствие знания о семантике**: хендлер не знает про "YouTube", "Discord" или "сессии". Он знает только про пакеты и их атрибуты (IP, порт, протокол, SNI, QUIC Initial и т.д.).

**Атомарность действия**: хендлер выполняет **одну** операцию над пакетом:
- PASS (пропустить без изменений)
- BLOCK (отбросить)
- MODIFY (применить стратегию: фрагментировать, добавить фейк, удалить SNI и т.д.)

### Логика хендлера

1. Захватить пакет от WinDivert
2. Извлечь признаки пакета (dst_ip, dst_port, proto, опционально SNI/QUIC markers)
3. Сделать lookup в Decision Graph с этими признаками
4. Получить решение (конкретную стратегию или PASS/BLOCK)
5. Применить решение
6. Вернуть пакет в стек (или отбросить)

### Стратегии как атомарные операции

Стратегия — это **чистая функция** преобразования пакета:

```
Strategy :: Packet → ModifiedPacket | DROP
```

Примеры стратегий:
- **FRAG**: разрезать TCP-сегмент на фрагменты
- **FRAG_REV**: разрезать + отправить в обратном порядке
- **TLS_FAKE**: отправить фейковый ClientHello перед настоящим
- **DROP_RST**: отбросить RST-пакеты
- **NO_SNI**: удалить SNI из TLS ClientHello

**Критично**: стратегия не знает про другие стратегии, не вызывает их, не имеет побочных эффектов вне своей области.

### Особый случай: глобальные блокировки

Действия типа "блокировать весь UDP/443" реализуются не как "стратегия", а как **политика с глобальным scope** (см. Policy Layer).

---

## 2. Policy Layer (уровень правил)

### Назначение
Декларативное описание условий применения стратегий обхода.

### Базовая сущность: Flow Policy

**Flow Policy** — это правило, описывающее:

**Match (условие срабатывания)**:
- `dst_ip_set`: множество IP-адресов назначения
- `proto`: протокол (TCP/UDP/ICMP)
- `port`: порт назначения
- `tls_stage` (опционально): этап TLS-соединения (ClientHello, ServerHello, etc)
- `quic` (опционально): признаки QUIC-пакета (Initial, Handshake)

**Action (действие)**:
- `PASS`: пропустить без изменений
- `BLOCK`: отбросить пакет
- `STRATEGY_ID`: применить конкретную стратегию (FRAG, TLS_FAKE, и т.д.)

**Scope (область действия)**:
- `LOCAL`: применяется только к пакетам, чей dst_ip входит в указанное множество
- `GLOBAL`: применяется ко всем пакетам, удовлетворяющим остальным условиям match

**Priority (приоритет)**:
- Целое число для разрешения конфликтов при пересечении условий
- Больший приоритет = выше в порядке рассмотрения

**Owner (владелец)**:
- Ссылка на Semantic Group (для отображения в UI)
- Execution Plane этого не видит

### Пример политики

```
FlowPolicy P1 {
  id: "youtube-ui-tcp443"
  
  match: {
    dst_ip_set: [142.250.185.206, 142.250.185.207, ...]
    proto: TCP
    port: 443
    tls_stage: ClientHello
  }
  
  action: STRATEGY(FRAG_REV)
  
  scope: LOCAL
  priority: 100
  owner: SemanticGroup("YouTube")
  
  metadata: {
    created: 2026-01-15T15:42:17Z
    enabled: true
  }
}
```

### Принципы работы с политиками

**Независимость**: политика не знает про другие политики. Она либо матчится на пакет, либо нет.

**Некомпозируемость**: политики не объединяются, не наследуются, не вызывают друг друга.

**Детерминизм**: для фиксированного набора политик и фиксированного пакета выбор всегда одинаков.

**Изменяемость без downtime**: политику можно создать, скомпилировать, атомарно включить/выключить без пересборки Execution Plane.

---

## 3. Decision Graph (движок выбора решений)

### Назначение
Выбор **ровно одной** политики для обработки пакета из множества потенциально подходящих.

### Алгоритм принятия решения

**Вход**: признаки пакета (dst_ip, proto, port, опционально TLS/QUIC markers)

**Процесс**:

1. **Сбор кандидатов**: найти все политики, чьи match-условия удовлетворяются пакетом
2. **Фильтрация невозможных**: исключить политики с физическими противоречиями (например, UDP-политика для TCP-пакета)
3. **Сортировка**: упорядочить кандидатов по приоритету (больший приоритет — выше)
4. **Выбор**: взять первую политику из отсортированного списка
5. **Логирование**: остальные кандидаты пометить как "skipped" (для observability)

**Выход**: действие из выбранной политики (PASS / BLOCK / STRATEGY_ID)

### Разрешение конфликтов

**Hard conflict (на этапе компиляции)**:
Две политики с одинаковым приоритетом имеют пересекающиеся match-условия → ошибка компиляции, конфигурация не принимается.

**Runtime conflict (в процессе работы)**:
Если обнаружено несколько подходящих политик (из-за неполноты match-условий) → применяется первая по приоритету, остальные логируются как conflicts, счётчики увеличиваются.

### Оптимизация производительности

Decision Graph может быть реализован как:
- **Hash Map** по dst_ip для быстрого поиска (O(1) для большинства случаев)
- **Decision Tree** для сложных условий с множественными атрибутами
- **Cache** частых решений (пакеты к одному и тому же endpoint получают кэшированное решение)

### Компиляция

Набор политик компилируется в Decision Graph при изменении конфигурации (добавление/удаление/изменение политики). Процесс компиляции включает:
- Проверку на hard conflicts
- Построение индексов по dst_ip, proto, port
- Предвычисление решений для популярных комбинаций

---

## 4. Semantic Layer (уровень пользовательской семантики)

### Назначение
Предоставление пользователю интерфейса для работы с **логическими сущностями** (приложениями, сервисами), скрывая сложность политик и пакетов.

### Базовая сущность: Semantic Group

**Semantic Group** — это именованная группа доменов, представляющая логическое приложение с точки зрения пользователя.

**Структура**:

```
SemanticGroup "YouTube" {
  id: "youtube-full"
  
  domains: [
    "youtube.com",
    "googlevideo.com",
    "ytimg.com",
    "ggpht.com",
    "gstatic.com"
  ]
  
  policies: [
    P1,  // youtube.com IPs → FRAG_REV
    P2,  // googlevideo.com IPs → TLS_FAKE
    P3,  // ytimg.com IPs → FRAG_REV
    P4,  // QUIC block для всех YouTube IPs
  ]
  
  status: ENABLED
  observability: {
    total_packets: 15420,
    policies_active: 4,
    last_activity: 2026-01-15T16:05:32Z
  }
}
```

### Операции пользователя

**Включить группу**: активировать все политики группы (компиляция → атомарное включение в Decision Graph)

**Выключить группу**: деактивировать все политики группы

**Изменить стратегию для домена**: создать новую политику (disabled), скомпилировать, атомарно заменить старую

**Добавить домен в группу**: резолвить домен → создать новые политики → добавить в группу

### Что пользователь НЕ видит

- IP-адреса (только домены и краткая статистика по endpoints)
- Детали WinDivert (фильтры, хендлеры, низкоуровневые операции)
- Приоритеты политик (управляются автоматически)
- Decision Graph (внутренняя механика)

### Что пользователь видит

- Статус группы (ENABLED / DISABLED / PARTIAL)
- Статистику по доменам ("youtube.com: 8472 пакета, стратегия FRAG_REV")
- Результаты работы ("UI работает, видео работает")
- Рекомендации ("googlevideo.com не обрабатывается, добавить?")

### Advanced-режим

Для экспертов предоставляется доступ к Policy Layer напрямую:
- Создание кастомных политик
- Управление приоритетами
- Просмотр Decision Graph
- Детальная observability

---

## Динамические аспекты

### DNS и изменение IP-адресов

**Проблема**: DNS-записи имеют TTL, IP-адреса доменов меняются.

**Решение**: DNS Cache Service

**DNS Cache** — отдельный сервис, который:
- Резолвит домены из Semantic Groups
- Хранит отображение `domain → IP set` с учётом TTL
- Периодически обновляет IP sets при истечении TTL
- Уведомляет Policy Layer об изменениях

**Обновление политик при изменении IP**:
1. DNS Cache обнаружил новые IP для youtube.com
2. Обновил `dst_ip_set` в соответствующих политиках
3. Триггер перекомпиляции Decision Graph
4. Атомарный swap нового Decision Graph
5. Execution Plane продолжает работу без downtime

**Критично**: WinDivert фильтры не пересобираются. Они статичны ("tcp.DstPort == 443"). Меняется только логика lookup внутри Decision Graph.

### Изменение стратегий без downtime

**Сценарий**: пользователь хочет изменить стратегию для googlevideo.com с TLS_FAKE на FRAG_REV.

**Процесс**:
1. Создать новую политику P2_new с action: STRATEGY(FRAG_REV), состояние: disabled
2. Скомпилировать новый Decision Graph с P2_new
3. Проверить на hard conflicts
4. Атомарно: disable P2_old, enable P2_new в Decision Graph
5. Старая политика помечается как archived (для истории)

**Downtime**: время атомарного swap (микросекунды, на уровне memory barrier).

---

## Наблюдаемость (Observability)

Observability встроена в архитектуру на всех уровнях.

### Метрики на уровне политик

Для каждой Flow Policy:
- **matched_packets**: сколько пакетов удовлетворили match-условию
- **applied_packets**: сколько раз действие было применено (= matched для выбранной политики)
- **skipped_count**: сколько раз политика была вытеснена другой с более высоким приоритетом
- **conflicts**: сколько раз произошёл runtime conflict
- **last_hit**: timestamp последнего срабатывания

### Метрики на уровне хендлеров

Для каждого Execution Plane handler:
- **total_packets**: общее количество обработанных пакетов
- **action_breakdown**: распределение по действиям (PASS: 1000, FRAG: 500, BLOCK: 50)
- **decision_latency**: время на lookup в Decision Graph (p50, p95, p99)
- **strategy_errors**: ошибки при применении стратегий

### Метрики на уровне Semantic Groups

Для каждой группы:
- **policies_active**: количество активных политик
- **total_traffic**: суммарный объём обработанного трафика
- **per_domain_stats**: статистика по каждому домену в группе
- **effectiveness**: эвристическая оценка эффективности (на основе успешности соединений после применения)

### Логирование

**Компактное логирование**:
```
[16:05:32] P1(youtube-ui) matched dst=142.250.185.206:443 → FRAG_REV applied
[16:05:33] P2(googlevideo) matched dst=172.217.16.238:443 → TLS_FAKE applied
[16:05:34] P_global(quic-block) matched dst=1.2.3.4:443 → BLOCK applied
```

**Детальное логирование** (debug mode):
- Полные признаки пакета
- Список всех кандидатов в Decision Graph
- Причина выбора конкретной политики
- Результат применения стратегии

### Связь с Network Portrait

Network Portrait остаётся **источником аналитики** для принятия решений о политиках:

- Portrait показывает: "У YouTube преобладает UDP:443 → вероятен QUIC"
- Система предлагает создать политику: BLOCK UDP:443 для YouTube IP (селективно)
- После применения Portrait показывает: "UDP:443 упал, TCP:443 вырос" → эффективность подтверждена

Portrait **не управляет** политиками напрямую, но предоставляет данные для их создания и оценки эффективности.

---

## Blast Radius Control (контроль области воздействия)

### Проблема
Некоторые техники обхода по природе глобальны (например, блокировка всего UDP/443). Применение таких техник может сломать другие приложения.

### Решение через Scope

Политики имеют атрибут **scope**:

**LOCAL**: действие применяется только к пакетам, чей dst_ip входит в `dst_ip_set` политики. Другие приложения не затрагиваются.

**GLOBAL**: действие применяется ко всем пакетам, удовлетворяющим match-условиям (например, весь UDP:443).

### Стратегия минимизации blast radius

1. **По умолчанию**: все политики создаются с scope=LOCAL
2. **Явное подтверждение**: при попытке создать GLOBAL-политику — показать предупреждение с описанием рисков
3. **Временные GLOBAL-политики**: возможность создать политику с TTL (автоматическое отключение через N секунд)
4. **Приоритеты**: LOCAL-политики получают более высокий приоритет, чем GLOBAL, чтобы селективные правила вытесняли глобальные

### Пример: селективная vs глобальная блокировка QUIC

**Селективная** (рекомендуемая):
```
FlowPolicy P_quic_youtube {
  match: {
    dst_ip_set: [все IP YouTube группы]
    proto: UDP
    port: 443
  }
  action: BLOCK
  scope: LOCAL
  priority: 100
}
```
→ Блокируется QUIC только для YouTube, игры работают.

**Глобальная** (опасная):
```
FlowPolicy P_quic_global {
  match: {
    proto: UDP
    port: 443
  }
  action: BLOCK
  scope: GLOBAL
  priority: 50
}
```
→ Блокируется весь QUIC в системе, может сломать игры и другие приложения.

---

## Жизненный цикл конфигурации

### Создание конфигурации

1. Пользователь: "Добавить YouTube"
2. Semantic Layer: создаёт SemanticGroup "YouTube" с доменами
3. DNS Cache: резолвит домены → IP sets
4. Policy Layer: создаёт политики для каждого домена (disabled)
5. Decision Graph: компилирует новый граф с проверкой на conflicts
6. Атомарное включение: политики переводятся в enabled
7. Execution Plane: начинает обрабатывать пакеты по новым правилам

### Изменение конфигурации

1. Пользователь: "Изменить стратегию для googlevideo.com"
2. Policy Layer: создаёт новую версию политики P2_v2 (disabled)
3. Decision Graph: компилирует с P2_v2
4. Проверка на conflicts
5. Атомарный swap: P2_v1 → disabled, P2_v2 → enabled
6. P2_v1 помечается как archived

### Удаление конфигурации

1. Пользователь: "Выключить YouTube"
2. Semantic Layer: деактивирует группу
3. Policy Layer: все политики группы → disabled
4. Decision Graph: перекомпиляция без этих политик
5. Execution Plane: пакеты для YouTube IP больше не обрабатываются (PASS)

---

## Сравнение с альтернативными подходами

### vs Single-Owner модель

**Single-Owner**: один активный владелец обхода в момент времени.

**Проблема**: при добавлении нового домена (googlevideo.com) старый (youtube.com) деактивируется → UI ломается.

**Policy-Driven**: нет понятия "активного владельца". Все политики активны одновременно, каждый пакет получает своё решение.

### vs Accumulative Sessions модель

**Accumulative**: карточки накапливаются в сессии, endpoints объединяются, к ним применяется одна стратегия.

**Проблема**: если youtube.com нужен FRAG_REV, а googlevideo.com нужен TLS_FAKE — как объединить?

**Policy-Driven**: каждый домен имеет свою политику со своей стратегией. Политики не объединяются, а сосуществуют. Пакеты к youtube.com обрабатываются по P1 (FRAG_REV), пакеты к googlevideo.com — по P2 (TLS_FAKE).

### vs Композитные стратегии

**Композитные**: создаём pre-defined bundles типа "Aggressive = Frag+Rev + TLS_Fake + Drop_RST".

**Проблема**: bundle применяется ко всем endpoints одинаково, даже если какая-то техника избыточна или вредна для конкретного сервиса.

**Policy-Driven**: каждый endpoint получает оптимальную для него стратегию через отдельную политику.

---

## Преимущества архитектуры

### ✅ Фундаментальная согласованность
Архитектура построена вокруг ограничений платформы, а не вопреки им. Нет внутренних противоречий.

### ✅ Детерминизм
Для одного и того же пакета при одном и том же наборе политик решение всегда одинаково. Нет гонок, нет недетерминированного поведения.

### ✅ Масштабируемость
Можно добавить сотни политик. Decision Graph с правильной индексацией выбирает решение за O(1) или O(log N).

### ✅ Изменяемость без downtime
Новые политики добавляются, старые удаляются, стратегии меняются — всё атомарно, без остановки трафика.

### ✅ Наблюдаемость на всех уровнях
Встроенные метрики и логирование на каждом слое. Всегда понятно, что происходит и почему.

### ✅ Разделение ответственности
Execution Plane не знает про семантику. Policy Layer не знает про WinDivert. Semantic Layer не знает про политики. Каждый слой решает свою задачу.

### ✅ Гибкость для экспертов
Advanced-режим даёт полный контроль над Policy Layer для точной настройки.

### ✅ Простота для обычных пользователей
Semantic Layer скрывает сложность. Пользователь работает с приложениями и группами, не думая про политики и пакеты.

---

## Недостатки и компромиссы

### ⚠️ Высокая сложность реализации
Это фундаментальная переработка архитектуры, требующая значительных инвестиций в разработку.

### ⚠️ Overhead на Decision Graph
Каждый пакет требует lookup. При большом количестве политик может потребоваться оптимизация (индексация, кэширование).

### ⚠️ Кривая обучения для экспертов
Для использования Advanced-режима нужно понимать концепцию политик, приоритетов, scope.

### ⚠️ Не решает проблему умного DPI
Если DPI обновился и научился обходить стратегию — архитектура не поможет. Нужно обновлять сами стратегии (Execution Plane).

---

## Применимость

### Когда использовать эту архитектуру

**✓ Зрелый продукт**: система вышла из прототипа и используется реальными пользователями

**✓ Сложные сценарии**: пользователи работают с множеством приложений и сервисов одновременно

**✓ Требования к надёжности**: downtime недопустим, нужна стабильность

**✓ Требования к observability**: важно понимать, что происходит в системе для отладки и поддержки

**✓ Долгосрочная перспектива**: архитектура строится на годы, а не на месяцы

### Когда НЕ использовать

**✗ Прототип / MVP**: overhead архитектуры избыточен для быстрых экспериментов

**✗ Одна цель**: если система обходит блокировки только для одного приложения — проще сделать специализированное решение

**✗ Частые изменения low-level механики**: если Execution Plane постоянно переписывается — Policy Layer станет помехой

---

## Путь миграции

Для существующих систем возможна поэтапная миграция:

### Этап 1: Изоляция Execution Plane
Вынести всю работу с WinDivert в отдельный слой с чётким API. Убрать зависимости от высокоуровневой логики.

### Этап 2: Введение Policy Layer
Создать Policy Layer как обёртку над существующей логикой. Постепенно мигрировать правила в формат Flow Policy.

### Этап 3: Реализация Decision Graph
Заменить ad-hoc логику выбора стратегий на детерминированный Decision Graph.

### Этап 4: Рефакторинг Semantic Layer
Адаптировать UI к работе с Semantic Groups и политиками.

### Этап 5: Оптимизация
Добавить индексацию, кэширование, performance-тюнинг Decision Graph.

---

## Заключение

Policy-Driven Execution Plane — это архитектурный подход, который признаёт физические ограничения систем перехвата пакетов как базовые принципы проектирования.

**Ключевой принцип**: обход — это функция от пакета, а не состояние системы.

Архитектура строится на четырёх слоях с чётким разделением ответственности, обеспечивая детерминизм, масштабируемость, наблюдаемость и изменяемость без downtime.

Это не серебряная пуля, это **рабочая конструкция** для зрелых систем.

---

## План внедрения в ISP_Audit (инкрементально, без «переписать всё»)

Цель плана: постепенно внедрить Policy‑Driven Execution Plane **внутри текущего движка** (TrafficEngine + IPacketFilter + BypassStateManager), сохранив:
- текущий UI/профиль обхода (bypass_profile.json, тумблеры),
- существующие метрики/activation/outcome,
- детерминизм и smoke‑гейты,
- возможность отката без ломки сценариев.

### Принцип внедрения (важно)

1) **Execution Plane не переписываем**: WinDivert остаётся, TrafficEngine остаётся, BypassFilter остаётся точкой модификации/дропа.
2) Добавляем новую сущность рядом: **PolicySet → DecisionGraphSnapshot**, который выбирает действие для пакета.
3) `BypassStateManager` остаётся SSoT и делает **атомарный swap** snapshot’а (как он уже сериализует Apply/Disable).
4) На первом этапе UI продолжает управлять привычными флагами, но под капотом они компилируются в политики.

### Этап 0 — Докконтракт и каркас (без изменения поведения)

**Что делаем:**
- Зафиксировать формальные типы: FlowPolicy (match/action/scope/priority/owner/ttl), DecisionGraphSnapshot (immutable), DecisionResult (PASS/BLOCK/STRATEGY_ID + policyId).
- Зафиксировать формат наблюдаемости: счётчики matched/applied/skipped/last_hit на policy.
- Выделить слой компиляции: PolicySetCompiler → DecisionGraphSnapshot.

**Гейты/DoD:**
- По умолчанию graph пустой → поведение полностью как сейчас.
- Добавить минимум unit/smoke: компилятор детектит hard‑conflicts (пересечение условий при равном priority).

### Этап 1 — Перенос UDP/443 (QUIC→TCP) в политики (минимальный риск)

Почему это безопасно: у нас уже есть селективный список dst IPv4 для UDP/443 и глобальный режим; это почти готовая FlowPolicy.

**Что делаем:**
- Политика P_quic_local: match(proto=UDP, port=443, dst_ip_set=observed/resolved), action=BLOCK, scope=LOCAL.
- Политика P_quic_global: match(proto=UDP, port=443), action=BLOCK, scope=GLOBAL (только по явному подтверждению).
- DecisionGraph выбирает BLOCK для UDP/443 по правилам priority/scope.

**Гейты/DoD:**
- Метрика `Udp443Dropped` остаётся валидной и растёт в тех же сценариях.
- В логах появляется строка вида: `policy=P_quic_local owner=YouTube matched/applied`.
- Есть быстрый kill‑switch: отключаем policy snapshot → возвращаемся к текущей логике.

### Этап 2 — Перенос временных блокировок (TTL endpoint block) в policy/ttl

Почему: текущий reconnect‑nudge — по сути временная GLOBAL/LOCAL‑политика с TTL.

**Что делаем:**
- Ввести TTL‑политики (авто‑disable по времени) с действием BLOCK на dst_ip_set:443 (TCP/UDP).
- Правило приоритетов: TTL‑политики всегда выше остальных (чтобы «пробить» любой MODIFY).

**Гейты/DoD:**
- Нет утечек: TTL гарантированно выключает политику.
- В UI можно показать «временная политика активна ещё N секунд».

### Этап 3 — Policy‑Driven для TCP/80 (Host tricks) (локальная зона влияния)

**Что делаем:**
- Вынести решение «применять ли HTTP Host tricks» в policy: match(proto=TCP, port=80, dst_ip_set=...), action=STRATEGY(HTTP_HOST_TRICKS).
- Реальная реализация стратегии остаётся в BypassFilter (как сейчас), но включается только при policy‑hit.

**Гейты/DoD:**
- Поведение Host tricks остаётся идентичным при равных условиях.
- Появляется observability: сколько раз policy сработала и сколько раз была вытеснена.

### Этап 4 — Главный этап: Policy‑Driven TLS для TCP/443 (per-domain/per-endpoint стратегии)

Это то, что решает YouTube/Steam «всё должно работать одновременно» без единой GroupEffectiveStrategy.

**Что делаем:**
- Вводим политики вида:
  - P_youtube_ui_tls: match(TCP, 443, tls_stage=ClientHello, dst_ip_set=youtube.com IPs) → STRATEGY(FRAG_REV)
  - P_googlevideo_tls: match(TCP, 443, tls_stage=ClientHello, dst_ip_set=googlevideo.com IPs) → STRATEGY(TLS_FAKE)
  - P_assets_tls: match(... gstatic/ytimg/...) → STRATEGY(FRAG_REV)
- DecisionGraph выбирает **ровно одну** стратегию на пакет (в рамках закона 1).
- Глобальные флаги типа DROP_RST могут остаться «параллельной политикой» на RST‑пакеты (а не как часть TLS‑стратегии).

**Гейты/DoD:**
- Можно одновременно иметь разные стратегии для разных доменов в одной группе.
- Появляется ясная «картинка»: какая policy реально обработала этот трафик.
- Если graph пустой или не матчится — fallback на текущую глобальную стратегию (переход без резкой ломки).

### Этап 5 — Semantic Groups поверх policies (группы как «пакет политик», а не «одна стратегия»)

**Что делаем:**
- Группа (YouTube/Steam) хранит домены и набор policies; UI работает с группой.
- Карточки доменов становятся «участниками» группы; действия пользователя обновляют policies (add/enable/disable/update).
- DNS/SNI/observed endpoints продолжают пополнять dst_ip_set политик (с TTL/cap), затем компилится новый DecisionGraphSnapshot.

**Гейты/DoD:**
- При применении к `googlevideo.com` карточка `youtube.com` не становится INACTIVE; у них просто разные policies.
- UI показывает статус группы: ENABLED/PARTIAL (например, есть домены без endpoints или без трафика).

### Этап 6 — Наблюдаемость и контроль blast radius как продуктовая фича

**Что делаем:**
- В UI: таблица policies (per-group/per-domain) с matched/applied/skipped/last_hit.
- Предупреждения для GLOBAL‑политик + TTL‑режим «временно».
- Экспорт snapshot’а DecisionGraph (JSON) в репорт.

**Гейты/DoD:**
- Пользователь может открыть «почему не сработало» без гаданий: policy не матчится / вытеснена / нет endpoints / нет трафика.

### Примечание про текущую архитектуру проекта

Текущий код уже на правильном пути:
- есть SSoT (`BypassStateManager`) и сериализация операций;
- есть селективный UDP/443 по observed IP;
- есть метрики и outcome‑probe.

Переход на Policy‑Driven — это в основном **вынесение выбора стратегии** из глобальных флагов в детерминированный lookup по пакету и расширение наблюдаемости.