# Bypass-архитектура и DPI: глубокое исследование

> Черновик. Цель файла — зафиксировать текущее понимание, а не предложить немедленные правки кода.

## 1. Цель обхода в контексте ISP_Audit

### 1.1. Что именно хотим обойти

- Провайдерский DPI, который ломает:
  - авторизацию / сетевую активность приложений (FsHud, Star Citizen, RSI Launcher и т.п.);
  - доступ к ряду HTTPS‑хостов (Google/CloudFront/Discord‑подобные паттерны).
- Типичные симптомы (по текущим логам и наблюдениям):
  - TCP RST через короткое время после TLS ClientHello;
  - зависание TLS handshake (timeout без явного RST);
  - возможный DNS‑spoof (фейковые IP / отсутствие ответа);
  - **важно:** проблема воспроизводится даже при наличии нашей текущей TLS‑фрагментации.

### 1.2. Как выглядит нормальный флоу для приложения

Упрощённый сценарий для проблемного приложения (FsHud / Star Citizen launcher):

1. **DNS:** приложение резолвит домен (обычно системный DNS, иногда DoH внутри самого клиента).
2. **TCP connect:** к целевому IP:port (чаще всего 443).
3. **TLS handshake:**
   - ClientHello → DPI анализирует SNI / начало ClientHello;
   - ServerHello → сертификат, ALPN и т.п.;
   - завершение рукопожатия.
4. **Прикладной протокол:** HTTPS / WebSocket / HTTP/2 поверх TLS.

Наша задача: сделать так, чтобы при наличии DPI **этот флоу проходил**, не ломая сам TLS/HTTP для приложения.

### 1.3. Критерии успеха (KPI)

Для оценки эффективности внедряемых техник:
- **TLS Handshake Success Rate:** ≥80% соединений к критическим доменам (`*.robertsspaceindustries.com`, `*.cloudfront.net`) завершаются успешно за <5 секунд.
- **RST Suppression:** RST blocker считается эффективным, если <5% соединений получают RST после активации защиты (при условии, что без защиты было >50%).
- **UDP Stability:** Отсутствие `ERROR 30000` в течение 15-минутной игровой сессии.

---

## 2. Как мы используем WinDivert сейчас

### 2.1. Слои и роли

Сейчас в проекте используются минимум два слоя WinDivert:

1. **WINDIVERT_LAYER_FLOW** — в `TrafficAnalyzer` (анализ потоков):
   - цель: получить список реальных соединений процесса (кто с кем говорит, порты, протоколы);
   - обязательные флаги по доке для FLOW: `Sniff | RecvOnly`;
   - DPI обход *не* реализуется на этом слое, он чисто аналитический.

2. **WINDIVERT_LAYER_NETWORK** — в `WinDivertBypassManager` (реальный обход):
   - **TLS fragmenter**:
     - слой: `Network`;
     - фильтр: `"outbound and tcp.DstPort == 443 and tcp.PayloadLength > 0"` (или вариант через `BuildTlsFragmentFilter`);
     - приоритет: `200` (выше, чем дефолтные 0);
     - флаги: `None` → классическая схема "capture / modify / reinject".
   - **RST blocker**:
     - слой: `Network`;
     - фильтр: `"tcp.Rst == 1"` (двунаправленный);
     - приоритет: `0`;
     - флаги: `Sniff | Drop` (попытка одновременно видеть и дропать RST);
     - обработчик: `PumpPackets` логирует RST и не вызывает `Send`.
   - **Redirector**:
     - слой: `Network`;
     - фильтр: конструируется `BuildRedirectFilter(...)`, вида `"outbound and tcp and (tcp.DstPort == X or ...)"` / UDP аналог;
     - приоритет: `0`;
     - флаги: `None` → перезаписывает IP/порт и реинжектит.

### 2.2. Жизненный цикл пакета через наши хэндлы

Упрощённо для исходящего TCP к 443:

1. Приложение → стек → **Network‑слой WinDivert**:
   - сначала обрабатывается хэндл с **наибольшим приоритетом**:
     - TLS fragmenter (`priority=200`) видит первый пакет с payload (ClientHello) при `tcp.DstPort == 443`;
     - он может фрагментировать ClientHello на 2 сегмента и реинжектить оба.
2. После этого пакет(ы) могут пройти через другие Network‑хэндлы с **меньшим приоритетом**, если фильтры совпадают:
   - Redirector (`priority=0`) теоретически может поменять адрес/порт для трафика, если настроен профилем.
   - RST blocker (`priority=0`) **для исходящих RST**: если DPI/OS послал RST, этот хэндл должен его поймать и не реинжектить.
3. Дальше трафик уходит в сеть.
4. В обратную сторону (входящие пакеты):
   - RST blocker на `Network` уровне может поймать входящие RST от DPI/сервера;
   - Redirector может изменить адрес/порт для инбонда (например, для ответа от редирект‑цели).

Важно: пакет, который был перехвачен и модифицирован TLS‑фрагментатором на приоритете 200, после `WinDivertSend` снова проходит через стек и может быть **снова** захвачен WinDivert, но уже хэндлами с приоритетом 0. То есть Redirector и RST‑блокер видят уже модифицированный трафик (фрагментированный ClientHello), а не оригинальный поток приложения.

### 2.3. Что работает, а что нет

- **TLS fragmenter**:
  - подтверждён логами: десятки/сотни ClientHello реально фрагментируются (см. `debug_trace.log`).
  - дедупликация по соединению была удалена — теперь фрагментируется каждый новый ClientHello.
- **RST blocker**:
  - логика обработки RST реализована, парсер IP/TCP корректен;
  - **но** WinDivert‑хэндл часто **не открывается**:
    - в логах: `"[WinDivert] WARNING: RST blocker failed to open (likely conflict with Flow layer)"`;
    - ни одной записи `"RST DROPPED"` → в реальности RST не блокируются.
- **Redirector**:
  - работает для профилей, но в текущем DPI‑сценарии не является ключевым.

---

## 3. Как это делает GoodbyeDPI / zapret архитектурно

### 3.1. GoodbyeDPI

- Работает **только на Network‑слое** WinDivert:
  - никакого FLOW‑слоя для обхода, только Network (TCP/UDP);
  - даёт себе максимальный контроль над первыми пакетами (HTTP/HTTPS/DNS).
- Основные техники (по README и исходникам):
  - TCP‑фрагментация первых пакетов (HTTP запрос / TLS ClientHello);
  - TLS‑фрагментация по SNI (`--frag-by-sni`);
  - reverse‑frag (`--reverse-frag`): посылка сегментов в обратном порядке;
  - HTTP‑тюнинг: `Host` → `hoSt`, пробелы, регистры, и т.п.;
  - Fake Request Mode: поддельные HTTP/HTTPS пакеты с низким TTL, неправильной checksum/SEQ;
  - DNS редирект: `--dns-addr/--dns-port` → уход от провайдерского DNS.
- **Важно:** GoodbyeDPI не смешивает WinDivert FLOW‑слой и Network‑обход; вся логика DPI обхода сосредоточена на Network.

### 3.2. zapret (nfqws/winws)

- Также сосредотачивается на "каноничном" слое перехвата (Linux: NFQUEUE, Windows: WinDivert Network);
- FLOW / socket слои используются максимум для диагностики, но не для критического bypass.

Вывод: **оба проекта избегают конфигураций, где обход зависит от одновременного использования FLOW и Network для одних и тех же TCP событий**.

---

## 4. Гипотетическая модель DPI провайдера

На базе симптомов (RST после ClientHello, таймауты, DNS‑аномалии) и типичных паттернов российских DPI можно предположить:

1. **DNS‑этап**:
   - DPI/резолвер может подменять IP для запрещённых доменов;
   - либо блокировать сам запрос/ответ (нет ответа → DNS timeout).

2. **TCP/TLS‑этап**:
   - DPI инспектирует первые 1–2 пакета с payload:
     - для HTTP — заголовок `Host` и часть URI;
     - для HTTPS — ClientHello, особенно поле SNI.
   - При совпадении с запрещённым хостом:
     - отправляет TCP RST от имени сервера (инъекция);
     - либо "глушит" соединение (ничего не шлёт в ответ);
     - может посылать HTTP 302 на цензурную страницу.

3. **Особенности работы DPI с фрагментацией**:
   - Многие DPI ломаются, если ClientHello/Host разбит на несколько сегментов необычным образом;
   - но часть DPI научилась работать с простыми случаями фрагментации, особенно если фрагментация выглядит "естественно".

Если это верно, то для успешного обхода нужно **одновременно**:

- не дать DPI увидеть полноту SNI/Host (фрагментация / reverse‑frag);
- заблокировать или "перенаправить" его попытки ответа (RST/302);
- при DNS‑спуфинге — использовать альтернативный канал резолва (DoH/DNS‑redirect).

---

## 5. Где именно мы сейчас промахиваемся

### 5.1. TLS‑фрагментация без RST‑блокера

- Мы уже фрагментируем ClientHello (иногда экстремально, до 2 байт);
- но если DPI **всё равно** решит, что это запрещённый хост, он может:
  - послать TCP RST → у клиента соединение обрывается;
  - наши логи показывают, что RST‑блокер не открылся → RST доходит до приложения.
- В результате даже "идеальная" фрагментация не спасает, потому что вторая половина обхода (RST‑block) не работает.

### 5.2. Конфликт Flow‑слоя и RST‑хэндла

- Из логов: `"RST blocker failed to open (likely conflict with Flow layer)"`.
- Возможные причины (по доке и типичной практике):
  1. **Ограничения драйвера/окружения:**
     - некоторые системы/антивирусы/другие драйверы плохо переносят одновременное использование WinDivert на разных слоях/фильтрах;
  2. **Пересечение фильтров и приоритетов:**
     - если уже есть Network‑хэндл с широким фильтром и приоритетом, второй с пересекающимся фильтром может вести себя нестабильно;
  3. **Комбинация флагов:**
     - редкий, но возможный баг драйвера при `Sniff|Drop` на Network при уже активном Flow‑слое (нужно проверять экспериментально).

На практике это означает: **Flow‑анализатор сейчас конкурирует с RST‑блокером за одни и те же события**, и RST‑хэндл в итоге не живёт. Это ядро текущей проблемы: любые сложные сценарии совместного использования FLOW+NETWORK (как в варианте B) потенциально хрупки и зависят от конкретной реализации/версии драйвера WinDivert и окружения (антивирусы, другие WFP‑фильтры).

### 5.3. Отсутствие Fake Request Mode и DNS‑редиректа

- Мы не отправляем никаких fake TLS/HTTP пакетов:
  - DPI всегда получает "честный" ClientHello/запрос и может обрывать его;
  - в GoodbyeDPI/ zapret Fake Request Mode часто является ключевым элементом обхода.
- Мы не перенаправляем DNS поверх нестандартных портов:
  - при чистом DNS‑спуфинге это может быть единственным решением.

---

## 6. Минимальный реалистичный набор техник для твоего кейса

### 6.1. Обязательные элементы

1. **Рабочий RST‑блокер на Network‑слое**
   - корректно открывающийся хэндл, который:
     - видит и логирует RST (inbound/outbound);
     - не реинжектит их (дропает);
     - сосуществует с Flow‑слоем (или получает эксклюзив по времени).

2. **TLS‑фрагментация с таргетингом по профилю**
   - не глобально для всего 443, а для целей из профилей (Star Citizen/FsHud);
   - желательно — опция "резать около SNI" (хотя бы грубая версия) и/или reverse‑frag.

### 6.2. Желательные элементы

3. **Простой Fake Request Mode для TLS**
   - 1–3 поддельных ClientHello с:
     - низким TTL (умирают до DPI и не доходят до реального сервера);
     - либо неправильными SEQ/CHK (с точки зрения DPI выглядят "валидно", но стек их отбросит);
   - вызываются перед реальной попыткой TLS для подозрительных хостов (`TLS_DPI`/`TCP_RST`);
   - отправляться могут:
     - либо через WinDivert (как impostor‑пакеты с `addr.Impostor = 1` и ручной корректировкой чек‑сумм через `WinDivertHelperCalcChecksums`),
     - либо через raw‑socket/`Socket` с установленным TTL и отключенной автоматической перерасчёткой checksum (где это возможно);
   - важно: fake‑пакеты должны быть достаточно реалистичными, чтобы DPI их принял за настоящие (структура ClientHello, SNI и т.д.), но при этом гарантированно **не ломали** реальное соединение.
   - для реалистичности потребуется:
     - либо извлекать шаблоны реальных ClientHello из живого трафика (и лишь немного модифицировать их поля),
     - либо генерировать ClientHello с помощью криптографически корректных библиотек (TLS‑стек, который умеет формировать валидные рукопожатия);
   - простая отправка случайных байт с низким TTL почти наверняка не сработает против продвинутых DPI, которые валидаируют структуру TLS.

4. **DNS‑редирект на нестандартный порт**
   - как стратегия для `DNS_FILTERED` / `DNS_BOGUS`:
     - фильтр для `udp.DstPort == 53` на Network‑слое;
     - переписывание dst IP/port на фиксированный публичный резолвер **только если точно известно**, что он слушает на нестандартном порту (например, Yandex 77.88.8.8:1253);
      - для Cloudflare/Google и прочих резолверов по умолчанию **нельзя** просто брать произвольный нестандартный порт — нужно явно проверить их документацию/поведение.

### 6.3. Необязательные (можно позже)

5. **HTTP‑трюки (Host/пробелы/регистр)**
   - полезны для HTTP, но для твоего основного кейса (TLS‑heavy, авторизация клиентов) второстепенны.

6. **Сложный auto‑TTL / reverse‑frag**
   - отдельный тюнинг под конкретные сети, можно делать после того, как заработает базовая связка TLS_FRAG + RST_BLOCK + DNS_REDIR.

---

## 7. Диагностическая матрица "симптом → техника обхода"

| Симптом (диагностика)                                | Предполагаемый тип блокировки | Техника обхода (первой линии)                          | Ожидаемый результат                                      |
|------------------------------------------------------|-------------------------------|---------------------------------------------------------|----------------------------------------------------------|
| DNS NXDOMAIN / timeout, DoH OK                      | `DNS_FILTERED`                | DoH / DNS redirect на публичный резолвер               | Домен успешно резолвится в рабочий IP                    |
| DNS отвечает приватными IP (10.x, 192.168.x, 127.x) | `DNS_BOGUS`                   | DNS redirect + проверка IP                             | Подмена IP устраняется, соединения идут в реальный CDN   |
| TCP connect OK, RST сразу после ClientHello         | `TCP_RST` / активный DPI      | RST_BLOCK + (опционально) Fake TLS                     | RST‑инъекции не доходят до клиента, TLS завершается OK   |
| TCP connect OK, TLS зависает без RST                | `TLS_DPI`                     | TLS_FRAG (по профилю/SNI) + Fake TLS                   | DPI не классифицирует сессию, рукопожатие завершается    |
| HTTP 302/блок‑страница при HTTP, HTTPS OK           | HTTP‑цензура                  | HTTP‑тюнинг (Host/пробелы/регистр)                     | HTTP возвращает нормальный контент, 302 исчезают         |
| UDP пакеты уходят, ответов нет                      | `UDP_DROP` / DPI по UDP       | UDP Fake initial (как в zapret)                        | Появляются стабильные ответы на игровые/voice порты      |
| Всё в целом медленно, но не падает                  | `SLOW_CONNECTION` / throttling| Обход не обязателен, лишь диагностика                  | Пользователь видит, что это не блок, а деградация канала |

Эта матрица не исчерпывающая, но задаёт основу для `ProblemClassifier` и `BypassStrategyPlanner`: любой новый симптом должен явно мапиться на тип блокировки и конкретный набор техник.

---

## 8. Архитектурное предложение для bypass‑слоя

### 8.1. Развести роли WinDivert и системных API

1. **WinDivert (Network‑слой):**
   - единственный источник правок пакетов:
     - TLS‑фрагментация;
     - RST‑блокинг;
     - DNS‑редирект;
     - Fake Request Mode.
   - не используется для долгоживущего Flow‑снифа (по возможности).

2. **Системные API / вспомогательные механизмы:**
   - `GetExtendedTcpTable` / `GetExtendedUdpTable` → `TcpConnectionWatcher` для привязки IP/портов к PID (FsHud/игра);
   - при необходимости ETW / PerfCounters для продвинутой диагностики, но не для самого обхода.

3. **WinDivert FLOW‑слой (`TrafficAnalyzer`):**
   - либо:
     - используется только для GUI‑диагностики и не активен во время агрессивного обхода;
   - либо:
     - полностью заменяется на `TcpConnectionWatcher`, а Flow‑хэндл вообще не открывается (более чистая архитектура для bypass).

### 8.2. Варианты устранения конфликта Flow vs RST

**Вариант A (жёсткий):**

- Во время активной bypass‑сессии (LiveTesting/авторизация):
  - Flow‑хэндл временно **отключается**;
  - активен только Network‑слой (TLS fragmenter + RST blocker + DNS redirect);
  - после завершения теста Flow‑хэндл включается обратно.

Плюсы:
- максимально простая модель с точки зрения драйвера;
- минимальный риск конфликтов.

Минусы:
- во время обхода временно нет Flow‑диагностики.

**Вариант B (мягкий, более сложный):**

- Оставить Flow‑хэндл, но:
  - строго соблюдать флаги для FLOW (`Sniff | RecvOnly`);
  - RST‑хэндл на Network открыть **без** `Sniff|Drop`, только с `flags = 0`:
    - пакеты будут блокироваться **только если мы их реально читаем** через `WinDivertRecv` и потом **не** вызываем `WinDivertSend`;
    - если `Recv` не вызывать, они повиснут в очереди и со временем будут дропаться драйвером по таймауту/лимиту очереди (что всё равно влияет на соединения), поэтому нужен фоновой consumer (`PumpPackets`), который стабильно вычитывает RST;
  - гарантировать, что на одном приоритете нет пересекающихся фильтров с другим Network‑хэндлом типа `true`.

**Вариант C (приоритетное разведение Flow и Network):**

- Использовать сильно различающиеся приоритеты для слоёв:
  - Flow‑хэндл открыть с приоритетом, условно, `-1000` (минимальный),
  - Network‑хэндлы (TLS fragmenter, RST blocker, DNS redirect) держать в диапазоне `0..+200`.
- Идея: даже если драйвер/другая логика каким‑то образом перекрещивают события, мы гарантируем, что критичная для обхода обработка на Network произойдёт *отдельно* от Flow‑нотификаций.
- Это не убирает логическую конкуренцию полностью, но уменьшает вероятность неожиданных взаимодействий между Flow‑и Network‑хэндлами.

Практический приоритет проверки вариантов:
- сначала попробовать **Вариант C** (минимальные изменения, лишь разведение приоритетов и фильтров);
- если не даёт стабильного результата — рассматривать **Вариант A** как более надёжный для обеспечения работы bypass и компенсировать потерю Flow‑диагностики усиленным логированием на Network‑слое.

### 8.3. Где фиксировать это в коде/документации

- **Код:**
  - `TrafficAnalyzer` — чётко указать (и обеспечить) использование корректных флагов Flow‑слоя;
  - `WinDivertBypassManager` — привести RST/TLS/DNS‑хэндлы к согласованной схеме (фильтры, приоритеты, флаги);
  - `LiveTestingPipeline` — явно различать режимы "diag only" vs "active bypass".

- **Документация:**
  - текущий файл (`docs/bypass_architecture_deep_dive.md`) как основа;
  - `docs/bypass_strategy_todo.md` — список конкретных задач по реализации техник (уже есть, нужно только актуализировать под эту архитектуру).

---

## 9. Отладка: как понять, что именно сработало

Идея: каждая техника обхода должна иметь **наблюдаемые артефакты** в логах и в сетевом поведении.

**TLS‑фрагментация:**
- Логи `WinDivertBypassManager`:
  - счётчики `ClientHello detected` и `ClientHello fragmented successfully` растут;
  - размер фрагментов соответствует профилю (`FirstFragmentSize`/`Threshold`).
- Поведение:
  - без RST‑блокера возможны всё те же RST после ClientHello → сама по себе фрагментация не гарантирует успех.

**RST‑блокер:**
- Логи:
  - наличие строки вида `RST blocker started with filter: tcp.Rst == 1` без предупреждений;
  - появление сообщений `RST DROPPED: src:port -> dst:port, total=N`;
  - отсутствие новых RST от DPI в `debug_trace.log` после активации.
- Поведение:
  - ранее обрывавшиеся TLS сессии больше не падают с RST, но могут упираться в timeout → важно фиксировать разницу (RST → timeout → success).

**Fake Request Mode:**
- Логи:
  - явные маркеры "отправлен fake ClientHello" с указанием SNI/TTL/режима (WrongSeq/WrongChk);
  - счётчики отправленных fake‑пакетов перед каждой реальной попыткой TLS.
- Поведение:
  - после нескольких fake‑пакетов реальная сессия перестаёт получать RST/302;
  - возможен небольшой рост латентности при первом соединении.

**DNS‑редирект:**
- Логи:
  - сообщения о переписывании DNS запросов: `DNS REDIRECT: srcIP -> resolverIP:port, qname=...`;
  - фиксация того, на какой резолвер и порт идёт трафик.
- Поведение:
  - системный `nslookup`/`dig` к проблемным доменам начинает возвращать другие (ожидаемые) IP;
  - Stage2 DNS‑диагностика (`DnsTest`) переходит из `DNS_FILTERED/DNS_BOGUS` в `OK`.

**Совместная проверка:**
- Для каждой целевой цели (host:port) в отчёте LiveTesting полезно хранить:
  - исходное состояние (до обхода);
  - список активированных техник (TLS_FRAG / RST_BLOCK / DNS_REDIR / FAKE_TLS);
  - итоговый результат (успех/неуспех); 
  - краткое резюме: какой именно шаг изменил статус с Fail на Pass.

Дополнительно имеет смысл ввести **корреляционный идентификатор** на уровне соединения:
- для каждого TCP‑соединения (5‑tuple: src/dst IP/port + протокол) генерировать UUID или короткий хэш;
- проставлять этот ID во всех логах, относящихся к данному соединению:
  - обнаружение и фрагментация ClientHello;
  - фиксация и дроп RST;
  - отправка fake‑пакетов;
  - итоговые результаты тестов LiveTesting.

Это позволит по одному ID восстановить полную историю жизни соединения в логах и однозначно связать симптомы с применёнными техниками обхода.

---

## 10. Fallback‑стратегии, если базовый набор не помог

Даже после включения TLS_FRAG + RST_BLOCK + DNS_REDIR обход может не сработать. Тогда можно рассматривать более агрессивные/экзотические варианты.

### 10.1. Усиленный Fake Request / auto‑TTL

- Ввести ступенчатую стратегию:
  1. Базовый Fake TLS (1–2 пакета, фиксированный TTL/SEQ);
  2. Если не помогло — включать auto‑TTL:
     - измерять расстояние до DPI (по TTL инжектированных/возвращённых пакетов или по ответам ICMP/trace);
     - подбирать TTL так, чтобы fake‑пакеты гарантированно умирали **между клиентом и DPI** или чуть дальше, но до сервера.
  3. Увеличивать количество повторов (`fake-resend` аналогично GoodbyeDPI/zapret), но с лимитом, чтобы не заспамить сеть.

### 10.2. Reverse‑frag и более сложные схемы фрагментации

- Если простая TLS‑фрагментация и Fake TLS не помогают:
  - включать reverse‑frag для ClientHello;
  - экспериментировать с несколькими фрагментами (не только 2) и разными позициями разбиения (в районе SNI, в районе расширений TLS).

### 10.3. Переключение профилей / рекомендация VPN

- Если даже усиленный набор техник не дал результата:
  - явным образом фиксировать это в отчёте как "неудачный обход" для конкретного провайдера/сети;
  - предлагать пользователю fallback уровнем выше:
    - использовать проверенный VPN‑профиль (Podkop/bypass_profile.json);
    - или явно рекомендовать смену DNS/маршрута/канала связи, если поведение DPI слишком агрессивно.

---

## 11. Специфика Star Citizen и технические риски (Addendum)

### 11.1. UDP и игровой трафик (Gameplay)
В отличие от лаунчера (TCP/HTTP), сам геймплей Star Citizen полагается на UDP.
- **Проблема:** Если провайдер блокирует или шейпит UDP (DTLS/RakNet), игрок получит `ERROR 30000` (timeout) или постоянные дисконнекты.
- **Отличие от TCP:** Здесь нет явного Handshake (SYN/ACK), который можно защитить.
- **Стратегия обхода:**
  - Отправка "разогревочных" фейковых UDP-пакетов перед началом сессии (пробив NAT и DPI state).
  - Если используется DTLS — попытка фрагментации ClientHello (аналогично TCP), но на уровне UDP payload (сложно, так как порядок не гарантирован).
  - **Важно:** Избегать IP-фрагментации UDP пакетов (многие роутеры их дропают).

### 11.2. Anti-Cheat безопасность (EAC / BattlEye)
Мы работаем в пространстве ядра/драйвера рядом с античитом.
- **Риск:** Агрессивная модификация пакетов или инъекция странных последовательностей может триггерить бан.
- **Митигация:**
  - Никогда не модифицировать **payload входящих** пакетов (сервер -> клиент). Это красная тряпка для античита (integrity check fail).
  - Fake-пакеты должны быть структурно валидными (правильные заголовки), чтобы не выглядеть как атака на сервер.

### 11.3. Техническая реализация: Checksums и State
- **State Management (C# Performance):**
  - Для реализации "Fake Request только один раз" нужно хранить состояние (`IP:Port -> State`).
  - **Проблема:** На высоких скоростях (1Gbps+) управление словарём состояний в Managed-коде (C#) может создать нагрузку на GC и блокировки (lock contention).
  - **Решение:** Либо использовать "stateless" подход (слать фейк всегда, если это допустимо), либо использовать высокопроизводительные структуры (например, `ConcurrentDictionary` с очисткой по таймеру, но аккуратно).
- **Checksum Offloading:** При любой модификации (фрагментация, подмена IP) или инъекции (Fake) **обязателен** пересчет контрольных сумм (IP, TCP, UDP).
  - Использовать `WinDivertHelperCalcChecksums` (нативный API).
  - Без этого пакеты будут молча отброшены стеком Windows или первым же роутером.
- **UI Feedback при отключении Flow:**
  - Если мы выбираем **Вариант A** (отключение Flow-слоя), GUI "ослепнет".
  - Решение: GUI должен переходить в режим "Active Bypass Mode" — показывать пульс/статус на основе логов Network-слоя, а не списка пакетов.

---

## 12. Конкретные следующие шаги (Roadmap & Estimates)

### 12.1. Приоритизация (Phasing)
- **Фаза 1 (Критично):** Шаги 1-2. Без работающего RST-блокера и стабильной архитектуры всё остальное бессмысленно.
- **Фаза 2 (Тактически важно):** Шаг 3. Fake Request Mode, особенно для UDP геймплея Star Citizen.
- **Фаза 3 (Оптимизация):** Шаг 4. SNI-осознанная фрагментация.

### 12.2. Задачи

1. **RST‑хэндл (Fix & Flags)** [Оценка: 2-4 часа]
   - экспериментально заменить флаги с `Sniff|Drop` на `0` (или только `RecvOnly`) и проверить, начнёт ли он открываться рядом с Flow;
   - добавить явное логирование `GetLastWin32Error()` для попыток открытия RST‑хэндла.

2. **Развод ролей Flow / Network (Architecture)** [Оценка: 4-6 часов]
   - описать в `TrafficAnalyzer` и `WinDivertBypassManager` явное правило: когда включён агрессивный bypass, что происходит с Flow‑слоем;
   - реализовать механизм временного отключения Flow на время LiveTesting (Вариант A).

3. **Fake Request Mode MVP** [Оценка: 1-2 дня]
   - реализация отправки 1–2 фиксированных ClientHello перед реальным соединением;
   - интеграция с `WinDivertHelperCalcChecksums`;
   - DNS redirect для `DNS_FILTERED/DNS_BOGUS`.

4. **SNI‑осознанная TLS‑фрагментация** [Оценка: 4-8 часов]
   - спроектировать парсер ClientHello до уровня SNI;
   - добавить режим "резать перед SNI" для конкретных доменов из профиля.

---

## 13. План отката и риски (Rollback Strategy)

### 13.1. Сценарий: "Вариант A сломал Flow, а Bypass не работает"
Если отключение Flow-слоя приводит к зависанию GUI, а Network-слой не обеспечивает прохождение трафика:
1. **Immediate Revert:** Вернуть флаг `EnableFlowLayer = true` в конфигурации по умолчанию.
2. **Fallback Code:** Держать старую логику инициализации WinDivert под `#if !EXPERIMENTAL_BYPASS` или отдельным флагом фичи, чтобы можно было пересобрать стабильный билд за 5 минут.

### 13.2. Сценарий: "Античит банит за Fake UDP"
Если поступают жалобы на кики/баны:
1. **Kill Switch:** Реализовать удаленное отключение фичи через обновление `bypass_profile.json` (флаг `AllowFakeUdp: false`).
2. **Default Off:** Поставлять новые агрессивные техники выключенными по умолчанию ("Experimental" в UI).

---

## 14. Критические риски и ограничения (Final Review)

1. **UDP Blackhole:**
   - **Риск:** Если провайдер полностью блокирует UDP на игровых портах (whitelist-only), методы обхода (Fake/Frag) бессильны.
   - **Митигация:** Детектировать `UDP_DROP` и сразу предлагать VPN, не пытаясь применять bypass.

2. **Performance Bottleneck (C# State):**
   - **Риск:** Использование обычного `Dictionary` для трекинга соединений убьет производительность.
   - **Решение:** Использовать `ConcurrentDictionary` с фоновой очисткой (`Background Cleanup`) устаревших записей.

3. **Checksum Silent Fail:**
   - **Риск:** Пакеты с неверной контрольной суммой дропаются молча (silent drop) получателем или роутером. В логах отправки всё выглядит ОК.
   - **Решение:** Добавить валидацию в логах (debug-режим), подтверждающую факт пересчета контрольной суммы после модификации.

Этот документ не отвечает на вопрос "что именно поменять в 10 строках кода", но он фиксирует **архитектурную картину**: где применим WinDivert, где конфликтует FLOW vs Network, какие именно техники из GoodbyeDPI/zapret нам нужны, и почему одного `TLS_FRAGMENT` сейчас недостаточно для обхода твоего DPI, а также даёт матрицу симптомов, подходы к отладке и базовые fallback‑стратегии.

---

## 15. Пошаговый план реализации (Execution Plan)

### 15.1. Фаза 1 — Диагностика Flow и RST-блокер

1. **Упрощение модели шагов (Stage1/Stage2 → единый пайплайн):**
  - Перейти от концепции отдельных шагов UI ("Шаг 1", "Шаг 2") к модели "единый пайплайн аудита": пользователь нажимает одну кнопку "Запустить диагностику", далее все этапы выполняются последовательно без дополнительных действий.
  - В UI (`MainWindow.xaml`) оставить только высокоуровневый прогресс/этапы (DNS, TCP/TLS, DPI/обход, UDP/игра, Итог), но не заставлять пользователя вручную переключаться между шагами.

2. **Диагностика Flow-слоя (`TrafficAnalyzer`):**
  - Убедиться, что Flow-хэндл стартует **до** запуска целевого процесса (FsHud/игра) в LiveTesting.
  - Сузить фильтрацию до нужных протоколов/портов (минимизировать шум).
  - Добавить логирование: момент старта FLOW, первый перехваченный пакет, задержка между запуском процесса и первым событием.

3. **Привязка соединений к PID (`TcpConnectionWatcher`):**
  - Ввести или доработать компонент, использующий `GetExtendedTcpTable`/`GetExtendedUdpTable`.
  - Логировать только соединения, принадлежащие целевым процессам (FsHud, RSI Launcher, Star Citizen), чтобы не тонуть в лишних PID.

4. **RST-блокер на Network-слое (`WinDivertBypassManager`):**
  - Заменить флаги `Sniff|Drop` на `0` или `RecvOnly` и проверить, что хэндл стабильно открывается рядом с Flow.
  - Добавить логирование `GetLastWin32Error()` при неудачной инициализации.
  - Включить подробные логи попадания/дропа RST (inbound/outbound) для сравнения до/после.

5. **Ввод режима "Active Bypass" и флага `EnableFlowLayer`:**
  - В `LiveTestingPipeline` ввести два режима: `diag only` (Flow включен, Network-обход минимален) и `active bypass` (основной упор на Network, Flow может быть отключен).
  - Реализовать флаг конфигурации/профиля (`EnableFlowLayer`), который управляет запуском Flow-хэндла.

6. **UI-индикация стадий аудита (грубые фазы):**
  - Обновить `MainViewModel` и `MainWindow.xaml`, чтобы на основе `TestKind` и текущего состояния показывать пользователю крупные этапы:
    - "DNS → TCP/TLS → DPI/обход → UDP/игра → Итог".
  - Использовать существующий `ProgressStepper` как визуальную ось этих этапов (отображать активный шаг, завершённые — подсвечивать как пройденные).
  - Ввести человеко-понятные статусы для каждой фазы (например: "Проверяем DNS...", "Пробуем установить защищённое соединение с серверами игры...", "Запускаем обход DPI...").

### 15.2. Фаза 2 — Fake Request Mode (TLS/UDP)

5. **Базовый Fake TLS ClientHello:**
  - Реализовать отправку 1–2 фиксированных ClientHello перед реальным соединением для целевых доменов.
  - Интегрировать пересчёт checksum через `WinDivertHelperCalcChecksums`.
  - Вести логи: когда и для какого SNI был отправлен fake-пакет, с какими параметрами TTL/SEQ.

6. **State Management для Fake Mode:**
  - Ввести `ConcurrentDictionary` для отслеживания состояния соединений (`IP:Port -> State`).
  - Добавить фоновую очистку устаревших записей, чтобы избежать утечек и нагрузки на GC.

7. **Простой Fake UDP для геймплея:**
  - Реализовать отправку "разогревочных" UDP-пакетов для игровых портов Star Citizen.
  - Добавить конфигурационный флаг в `bypass_profile.json` для включения/отключения Fake UDP (с учётом античита).

8. **UI-индикация сетевой активности аудита:**
  - В `MainWindow.xaml` добавить компактный индикатор "Сеть" рядом с текущим шагом (например, точка/иконка: нет трафика / есть исходящий запрос / есть ответы).
  - В `MainViewModel` ввести свойства вида `IsNetworkActive`, `IsWaitingForResponse`, обновляемые из `AuditRunner`/результатов тестов.
  - В статусной строке явно показывать разницу между состояниями:
    - "Ждём ответ сервера (до 10 секунд — это нормально)";
    - "Нет сетевой активности — проверяем локальную конфигурацию".

### 15.3. Фаза 3 — SNI-осознанная фрагментация

8. **Парсер ClientHello до уровня SNI:**
  - Добавить в обход-слой разбор TLS ClientHello до поля SNI.
  - Ввести структуру профиля, описывающую домены/паттерны, к которым нужно применять SNI-фрагментацию.

9. **Режим "резать перед SNI":**
  - Реализовать стратегию фрагментации, которая гарантирует разделение ClientHello в районе SNI для заданных доменов.
  - Добавить отдельные логи/счётчики для SNI-осознанной фрагментации (отличать от простой).

10. **Тонкая настройка и A/B-тестирование:**
   - На основе логов и KPI из раздела 1.3 сравнивать эффективность разных режимов (без SNI-фрагментации, с ней, с Fake Request).
   - Закрепить рабочие комбинации техник в профилях (`Profiles/`), а в GUI обозначить их как рекомендуемые пресеты.

11. **UI-отражение режимов обхода и результатов:**
  - В `MainViewModel` добавить человеко-понятное описание активных техник обхода (например: "Включены: TLS-фрагментация, RST-блокер" / "Обход отключён, идёт только диагностика").
  - В отчёте и на финальном экране GUI показывать краткое резюме: какой шаг (Flow-only / Active Bypass / Fake Request / SNI-фрагментация) изменил статус с Fail на Pass для критических хостов.
  - Обеспечить, чтобы для рядового пользователя это выглядело как простое объяснение: "Где сломалось" и "Что мы попробовали сделать, чтобы обойти блокировку".

Этот план задаёт конкретную последовательность шагов от диагностики текущего поведения Flow/Network до внедрения сложных техник обхода (Fake Request, SNI-фрагментация) с возможностью поэтапного отката и измерения эффективности.