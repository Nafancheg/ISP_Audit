# ISP_Audit — Набросок архитектуры: «сетевой портрет приложения» (Network Portrait)

**Дата:** 13.01.2026
**Статус:** draft / архитектурные заметки

Цель этого документа — зафиксировать направление: как перейти от «перехватили хост → накидали рекомендации» к более устойчивой модели, где основным объектом является **приложение/процесс(ы)** и его **портрет протоколов/портов/паттернов трафика**, а рекомендации (и особенно опасные действия типа QUIC→TCP) имеют контролируемый **blast radius** и не ломают другие приложения.

---

## 1) Почему это важно (проблема)

Ключевой источник “кажется, что обход не работает” — это несовпадение **того, что мы лечим**, и **того, по чему реально идёт трафик**.

- TLS/DPI обход в текущем движке в основном воздействует на **TCP/443 (TLS ClientHello)**.
- Современные клиенты (браузеры, лаунчеры, часть игр) могут активно использовать **QUIC/HTTP3 (UDP/443)**.
- Если целевой трафик уходит в QUIC, то можно включить идеальные TLS-стратегии и всё равно не увидеть эффекта.

Отсюда и желание пользователя: «сделать так, чтобы работало без “глушить весь UDP/443”, иначе сломаем игру».

---

## 2) Главные цели дизайна

1) **App-agnostic:** не привязываться к YouTube/доменам, работать для любого приложения.
2) **Контроль blast radius:** любые “тяжёлые” меры должны быть либо:
   - селективными (по цели), либо
   - ограниченными по времени/условиям,
   - явно маркированными в UI.
3) **Наблюдаемость:** пользователь должен видеть, что именно сейчас воздействует на трафик (и на какой).
4) **Детерминизм:** решения должны быть воспроизводимыми (одинаковый вход → одинаковый вывод).

---

## 3) Определения

### 3.1. «Цель»
Цель — это **набор процессов** (PID-группа), которые мы считаем “тем самым приложением”.

Примеры:
- `chrome.exe` (несколько PID)
- “лаунчер + игра” (2+ PID)

### 3.2. «Сетевой портрет» (Network Portrait)
Портрет — это агрегированное описание того, **какие протоколы/порты/направления** использует цель за последнее окно времени.

Нам важно не содержимое трафика, а “карта активности”:
- TCP vs UDP
- порты (443/80/53/…)
- динамика (есть ли UDP/443, есть ли TCP/443)
- признаки отказов/вмешательств (RST, ретрансы, UDP unanswered)

### 3.3. «Безопасный обход»
Под безопасностью здесь подразумевается:
- минимизация влияния на нецелевые приложения;
- отсутствие “вечных” глобальных перехватов, если можно ограничить воздействие.

---

## 4) Предлагаемая модель данных (draft)

Минимальная структура, которую можно вывести в UI/лог и сохранять в отчёт:

- `TargetId` (логический идентификатор цели; например “chrome”, “steam+game”)
- `Pids[]` (активные PID цели)
- Окно агрегации: `WindowSeconds` (например 30с / 60с)
- `TransportSummary`:
  - `TcpConnectionsNew` (сколько новых TCP соединений)
  - `UdpFlowsNew` (сколько новых UDP “потоков”/сессий)
  - `TopRemotePortsTcp[]` (частоты)
  - `TopRemotePortsUdp[]` (частоты)
- `QuicHeuristics`:
  - `Udp443PacketsObserved` / `Udp443FlowsObserved`
  - `QuicInitialLikeObserved` (если можем детектить QUIC Initial)
  - `Confidence` (0..100)
- `Symptoms`:
  - `RstInjectedSuspected` (bool + score)
  - `TcpRetransRate` (оценка)
  - `TlsTimeouts` / `TlsAuthFailures`
  - `UdpUnansweredHandshakes` (если доступно)

Важно: это **не про домены**. Домены (SNI/HTTP Host) — отдельный слой фактов, который помогает “прицелиться”, но не должен быть единственным способом принятия решений.

---

## 5) Дерево решений (как использовать портрет)

### Шаг 0: есть ли вообще трафик цели?
- Если нет трафика → любые рекомендации “вилами по воде”, показываем `NO_TRAFFIC`.

### Шаг 1: доминирующий транспорт к 443
- Если есть **существенный UDP/443** у цели (по окну) → считаем, что QUIC вероятен.
- Если есть только **TCP/443** → применимость TLS-обхода высокая.

### Шаг 2: выбор техник с минимальным риском
- Если QUIC вероятен:
  - сначала **не включать глобальный** UDP/443 drop;
  - предпочесть селективное подавление по цели (см. раздел 6);
  - либо предложить пользователю вариант на стороне приложения (выключить HTTP3/QUIC в настройках) — но это уже вне нашего контроля.

### Шаг 3: проверка результата
- После apply показываем:
  - изменился ли портрет (например, упал UDP/443, появился TCP/443);
  - растёт ли метрика `Udp443Dropped` (если включали QUIC→TCP);
  - outcome probe (HTTPS) SUCCESS/FAILED/UNKNOWN.

---

## 6) Самый важный раздел: как не сломать игру (blast radius)

Ваш сценарий: «играю, на фоне YouTube». Опасение справедливое: **глобальный** `DropUdp443` может ухудшить работу игры, если игра использует QUIC или вообще UDP/443 (или близкие паттерны).

### 6.1. Принцип по умолчанию
- `QUIC→TCP` по умолчанию должен быть:
  - **выключен**, либо
  - включаться только как **селективный** режим по цели.

### 6.2. Селективный режим (по цели) — предпочитаемый
В проекте уже есть правильная идея: `DropUdp443` селективно по observed IPv4 адресам цели.

Смысл:
- мы подавляем UDP/443 **только на dst IP**, которые относятся к выбранной цели (например, “тот хост, с которым сейчас проблема”, или тот, что выставлен как цель обхода);
- побочные эффекты на другие приложения резко падают.

Ограничения:
- IPv6 селективность пока не реализована (риск). Поэтому при наличии IPv6 трафика нужно явно маркировать “возможна глобальность для IPv6”.

### 6.3. Глобальный режим — только как “последний молоток”
Глобальный `DropUdp443Global` должен требовать:
- явного подтверждения пользователем;
- отображения предупреждения в UI;
- (опционально) авто-таймаута/авто-отката.

### 6.4. Временные/условные ограничения
Чтобы ещё сильнее уменьшить риск:
- “глобальный” режим можно включать на ограниченное время (например 60–180 секунд) для проверки гипотезы, затем авто-откат.
- селективный режим можно ограничивать TTL списка IP, чтобы устаревшие цели не оставались.

### 6.5. Разделение по целям (идея на будущее)
Если мы придём к “runner/patcher”:
- обход может быть запускаемым/останавливаемым “на время сеанса цели”, а не “вообще включили и забыли”.

---

## 7) Где это живёт в текущей архитектуре (минимальная интеграция)

Минимально (без переделки всего):
- `DiagnosticOrchestrator`/`PidTrackerService` уже знают про tracked PIDs.
- `UdpInspectionService` уже умеет детектить QUIC-like и “unanswered”.
- `BypassStateManager` уже содержит логику селективного подавления UDP/443 по IP цели.

Что нужно добавить для “портрета”:
- агрегатор “счётчиков активности” по PID-группе (окна 30/60 секунд);
- лёгкий контракт DTO (см. раздел 4);
- вывод портрета в UI (как минимум в лог/панель статуса), чтобы пользователь видел “что сейчас происходит”.

---

## 8) UX: как это объяснять пользователю

В UI важно разделить две вещи:
1) **Что мы наблюдаем:** “у цели активно UDP/443 → вероятен QUIC”
2) **Что мы делаем:** “селективно подавляем UDP/443 к IP цели (N IP), счётчик дропа растёт”

И обязательно показывать режим:
- `QUIC→TCP: Off`
- `QUIC→TCP: Selective (dst IP = …)`
- `QUIC→TCP: Global (WARNING)`

---

## 9) Открытые вопросы / риски

- PID для UDP на уровне WinDivert Network Layer может быть недоступен (это ограничение Windows/слоя). Если для UDP нельзя уверенно связать с PID, то «портрет по PID» потребует корреляции (по endpoint ↔ процесс) и будет иметь `Confidence`.
- IPv6 селективность для UDP/443: если не сделана — глобальный эффект может проявляться только на IPv6, что опасно и должно быть явно видимо.

---

## 10) Итог (коротко)

- Network Portrait нужен, чтобы рекомендации были “в правильной ветке реальности” (TCP vs QUIC) без привязки к доменам.
- Самое опасное действие — глобальный UDP/443 drop — должно быть последним вариантом и максимально ограниченным.
- Селективный QUIC→TCP по цели — ключ к тому, чтобы “YouTube на фоне” не ломал игру.
